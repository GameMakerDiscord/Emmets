<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_gridselector</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>unique();
bgsFade();
depth = HUD_DEPTH-1;

debug = object_debug.debugGeneration;
debugDisplay = array("terrain", "objects", "walls", "gravel", "loot");
debugIndex = 0;

finished = false;
initialized = false;

timer = 0;
cave = noone;

/// MAP PARAMETERS
terrain = noone;
objects = noone;
walls = noone;
gravel = noone;
loot = noone;
        
hardrockFrequency = 0.7; // 0 = no hardrock, 1 = full hardrock
gravelFrequency = 0.2;
centeredCorridors = true;
corridorMinWidth = 1;
spawnSize = 4;
roomClearAmount = 0.3; //The highest, the less dirt there'll be in rooms
maxHardrockDistance = 12;
hardrockRangeMultiplier = 2;
buildingLootMultiplier = 1;
water = false;
waterRoomChance = 0.3;  // Each room has 30% of chance to be water

lava = false;
lavaRoomChance = 0.5;   // Each room has 50% of chances to be lava
lavaRooms = array(noone);

spawnScramblers = false;

frscs = getFancyMaterials();
filons = array(
    frscs[rrandom(array_length_1d(frscs)-1)], 
    frscs[rrandom(array_length_1d(frscs)-1)], 
    frscs[rrandom(array_length_1d(frscs)-1)], 
    frscs[rrandom(array_length_1d(frscs)-1)], 
    frscs[rrandom(array_length_1d(frscs)-1)], 
    frscs[rrandom(array_length_1d(frscs)-1)]
);
numberOfFilons = array_length_1d(filons);
filonRange = array(2, 4);

//BSP PARAMETERS
BSPSpaceBonus = 2;
BSPMinClusterOccupation = 0.76;
BSPDepth = 5; 
BSPMinRatio = 0.45; //H/W or W/H minimal ratio not to discard room.
BSPMinSize = 3;
BSPSafeBorder = 2;
BSPMinRooms = 3;


/// Internals
toDestroy = array(ds_map_create());

i = 0;
j = 0;
k = 0;

step = 0;
BSPStep = 1;

finalRoomList = ds_list_create();
finalCorridorList = ds_list_create();
incrementator = 0;
clusterList = ds_list_create();
pairs = ds_list_create();
workingClusterCreated = false;
doneInitialization = false;
clusterInited = false;
caveSize = noone;

initializedStep3 = false;
newPairList = noone;
spawn = noone;
spawnRoom = noone;
firstRoom = noone;
thisRandom = noone;
thisRoom = noone;
middleX = noone;
roomSize = noone;
thisPair = noone;
dirtList = noone;
fakeGrids = array(noone);

/// Display
loadingText = translate("LOADER", "loading");
status = "";

loaderWindow  = instance_create(0,0,object_ui_window_loading);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (instance_exists(loaderWindow)){
    loaderWindow.text = status;
}
if (finished &amp;&amp; initialized){
    status = "Done! ("+string(timer)+" seconds)";  
    object_game.inGame = true;
    object_game.gridSize = caveSize;
    
    if (!debug || keyboard_check_pressed(vk_space)){
        if (instance_exists(loaderWindow)){
            loaderWindow.die = true;
        }
        instance_destroy();
    }
}

if (!finished){
        
    if (room != loading){
        exit;
    }
    if (cave == noone){
        exit;
    }
    
    if (!doneInitialization){
        
        timer = get_timer();
        
        /////////////////
        ///
        /// INITIALIZATION AND CLEAN-UP
        ///
        /////////////////
    
        log("Initializing map parameters...");
        
        object_game.initialized = false;    
        object_game.inGame = false;
        
        caveSize = getRule(RULE_SIZE, cave);
        
        if (caveSize[0] &gt; 64){
            BSPDepth++;
        }
        
        terrain = ds_grid_create(caveSize[0], caveSize[1]);
        objects = ds_grid_create(caveSize[0], caveSize[1]);
        walls = ds_grid_create(caveSize[0], caveSize[1]);
        gravel = ds_grid_create(caveSize[0], caveSize[1]);
        loot = ds_grid_create(caveSize[0], caveSize[1]);
        
        ds_grid_clear(terrain, noone);
        ds_grid_clear(objects, noone);
        ds_grid_clear(walls, noone);
        ds_grid_clear(gravel, noone);
        ds_grid_clear(loot, noone);
                
        /// Initializaing terrain sprite
        
        var world = cave[? CAVE_WORLD];
        terrain_ini(caveSize[0],caveSize[1],
            TERRAIN_WALL_DIRT, getWorld(world, TERRAIN_WALL_DIRT),
            TERRAIN_WALL_HARDROCK,  getWorld(world, TERRAIN_WALL_HARDROCK),
            TERRAIN_WALL_UNBREAKABLE, getWorld(world, TERRAIN_WALL_UNBREAKABLE)
                    );
            
        log("Initialized GR terrain for size "+string(caveSize)+"");
        log("GR terrain state is "+string(global.terrain_walls_tilesets));
        for(var a=0; a&lt;(caveSize[0])*(caveSize[1]); a++){
            global.terrain_walls_tiles[a, 0] = 0
            global.terrain_walls_tiles[a, 1] = 0
        }
        /// End of
        
        global.gameRoom = room_add();
        room_set_width(global.gameRoom, caveSize[0]*G_CELLSIZE);
        room_set_height(global.gameRoom, caveSize[1]*G_CELLSIZE);
        room_set_view(global.gameRoom, 0, true, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 32, 32, 4, 4, -1);
        room_set_view_enabled(global.gameRoom, true);
        room_set_persistent(global.gameRoom, false); 
        room_set_background_colour(global.gameRoom, c_black, true);
        room_set_background(global.gameRoom, 1, true, false, tile_lasergrid, 0, -8, true, true, 0, 0, 0.3);
        
        global.currentCave = cave;
        
        random_set_seed(cave[? CAVE_SEED]);
        doneInitialization = true;
        
        log("Applying generation cave rules");

        //////////////////////////////
        ///                        ///
        ///     CAVE RULES         ///
        ///                        ///
        //////////////////////////////
        
        switch (cave[? CAVE_BONUS]){
            case CAVE_BONUSES.RESSOURCES_RICH:
                buildingLootMultiplier = 1.5;
                break;
                
            case CAVE_BONUSES.NO_HARDROCK:
                hardrockFrequency = 0.1;
                break;
                
            case CAVE_BONUSES.CRYSTALLINE:
                filonRange = array(5, 9);
                break;
                
            case CAVE_BONUSES.WATER_PRESENCE:
                water = true;
                break;
        }
        
        switch (cave[? CAVE_MALUS]){
            case CAVE_MALUSES.LAVA_PRESENCE:
                lava = true;
                break;
            
            case CAVE_MALUSES.SMALL_CAVE:
                numberOfFilons = 3;
                break;
                
            case CAVE_MALUSES.MORE_HARDROCK:
                hardrockFrequency = 0.95;
                break;
                
            case CAVE_MALUSES.RESIDUALS:
                filonRange = array(1, 2);
                break;
                
            case CAVE_MALUSES.RESSOURCES_POOR:
                buildingLootMultiplier = 0.5;
                break;
                
            case CAVE_MALUSES.ELECTRIC_VARIATION:
                spawnScramblers = true;
                break;
            
        }
        
    
        log("Starting map creation");
    }
    
    /////////////////
    ///
    /// ACTUAL MAP CREATION
    ///
    /////////////////
    
    switch (step){
        case 0:
            /// Creating rooms
            status = "Creating rooms";
            
            if (ds_list_size(finalRoomList) &lt; 2){    /// Automatically drop generations that have less than two rooms.
            
                incrementator++;
                ds_grid_clear(terrain, TYPE_VOID);
                ds_list_clear(finalRoomList);
                ds_list_clear(finalCorridorList);
                log("GENERATING ROOMS USING BSP - TRY "+string(incrementator), "MAPGENRT");
            
                var clusterList = ds_list_create();
                ds_list_add(clusterList, array(0+BSPSafeBorder,0+BSPSafeBorder,caveSize[0]-1-BSPSafeBorder, caveSize[1]-1-BSPSafeBorder));
                
                var pairs = ds_list_create();
                
                if (caveSize[0]-1 &gt; caveSize[1]-1){
                    split = 1;
                }
                else{
                    split = 0;
                }
                    
                for (var b = 0; b &lt; BSPDepth; b++){
                
                    var workingCluster = ds_list_create();        
                            
                    //Splitting EVERY cluster until we have leaves
                    for (var c = 0; c &lt; ds_list_size(clusterList); c++){ //For every cluster...
                        
                        var thisRoom = ds_list_find_value(clusterList, c);
                        thisPair =  ds_list_create();
                        
                        if (thisRoom[2]-thisRoom[0] &gt; thisRoom[3]-thisRoom[1]){
                            split = 0;
                        }
                        else{
                            split = 1;   
                        }
                        
                        switch (split){ //...we create two !
                            default:
                                var midX = round((thisRoom[0]+thisRoom[2])/2);
                                var splitPosX = round(random(thisRoom[2]-thisRoom[0])+thisRoom[0]);
                                splitPosX = round(lerp(splitPosX, midX, 0.7));
                                
                                firstRoom = array(thisRoom[0], thisRoom[1], splitPosX-BSPSpaceBonus, thisRoom[3]);
                                var secondRoom = array(splitPosX+1, thisRoom[1], thisRoom[2], thisRoom[3]);
                                ds_list_add(workingCluster, firstRoom, secondRoom); 
                                ds_list_add(thisPair, firstRoom, secondRoom);
                                break;
                                
                            case 1:
                                var midY = round((thisRoom[1]+thisRoom[3])/2);
                                var splitPosY = round(random(thisRoom[3]-thisRoom[1])+thisRoom[1]);
                                splitPosY = round(lerp(splitPosY, midY, 0.7));
                                
                                firstRoom = array(thisRoom[0], thisRoom[1], thisRoom[2], splitPosY-BSPSpaceBonus);
                                var secondRoom = array(thisRoom[0], splitPosY+1, thisRoom[2], thisRoom[3]);
                                ds_list_add(workingCluster, firstRoom, secondRoom); 
                                ds_list_add(thisPair, firstRoom, secondRoom);
                                break;
                        }
                        
                        // Last depth iteration
                         if (BSPDepth-1 == b){
                            //ETAP 1
                            //GENERATING RANDOM ROOMS INSIDE CLUSTER
                            for (var d = 0; d &lt; ds_list_size(thisPair); d++){
                            
                                var thisCluster = ds_list_find_value(thisPair, d);
                                
                                var newRoomW = round(random(thisCluster[2]-thisCluster[0]-(thisCluster[2]-thisCluster[0])*BSPMinClusterOccupation))+(thisCluster[2]-thisCluster[0])*BSPMinClusterOccupation;
                                var newRoomH = round(random(thisCluster[3]-thisCluster[1]-(thisCluster[3]-thisCluster[1])*BSPMinClusterOccupation))+(thisCluster[3]-thisCluster[1])*BSPMinClusterOccupation;
                                          
                                var newRoomX = thisCluster[0] + round(((thisCluster[2]-thisCluster[0])-newRoomW)/2);
                                var newRoomY = thisCluster[1] + round(((thisCluster[3]-thisCluster[1])-newRoomH)/2);
                                
                                var newRoom = array(newRoomX, newRoomY, newRoomX+newRoomW, newRoomY+newRoomH);
                                newRoom = clampRoomInsideAnother(newRoom, thisCluster); //Clamping it for security
                                
                                if ((newRoomW/newRoomH &lt; BSPMinRatio || newRoomH/newRoomW &lt; BSPMinRatio || newRoomH &lt; BSPMinSize || newRoomW &lt; BSPMinSize)){
                                    // Discarding it
                                    ds_list_replace(thisPair, d, noone)
                                }
                                else{
                                    ds_list_replace(thisPair, d, newRoom); //Replaced cluster with a valid room
                                }
                            }
                            
                            //ETAP 2
                            //CARVING ROOMS
                            for (var d = 0; d &lt; ds_list_size(thisPair); d++){
                            
                                var thisRoom = ds_list_find_value(thisPair, d);
                                
                                if (thisRoom != noone){
                                    ds_list_add(finalRoomList, thisRoom);
                                    log("Creating new room on "+string(thisRoom));
                                    if (water &amp;&amp; random(1) &lt; waterRoomChance){
                                        ds_grid_set_region(terrain, thisRoom[0], thisRoom[1], thisRoom[2], thisRoom[3], TYPE_WATER);
                                        log(string(thisRoom) + " is a water room");
                                    }
                                    
                                    else if (lava &amp;&amp; random(1) &lt; lavaRoomChance){
                                        ds_grid_set_region(terrain, thisRoom[0], thisRoom[1], thisRoom[2], thisRoom[3], TYPE_LAVA);
                                        lavaRooms[array_length_1d(lavaRooms)] = thisRoom;
                                        log(string(thisRoom) + " is a lava room");
                                    } 
                                    else{
                                        ds_grid_set_region(terrain, thisRoom[0], thisRoom[1], thisRoom[2], thisRoom[3], TYPE_DIRT);
                                    }
                                   
                                }
                            }
                            
                            ds_list_add(pairs, thisPair);
                         }
                     }
                     ds_list_copy(clusterList, workingCluster);
                     toDestroy[array_length_1d(toDestroy)] = workingCluster;
                }
                
                //ETAP 3 
                //CORRIDORING
                
                var newPairList = ds_list_create();
                
                for (var a = 0; a &lt; BSPDepth; a++){
                    for (var b = 0; b &lt; ds_list_size(pairs); b++){
                    
                        var thisPair = ds_list_find_value(pairs, b);
                        firstRoom = ds_list_find_value(thisPair, 0);
                        var secondRoom = ds_list_find_value(thisPair, 1);
                        
                        if (is_undefined(firstRoom) &amp;&amp; is_undefined(secondRoom) || (firstRoom == noone &amp;&amp; secondRoom == noone)){
                            ds_list_delete(pairs, b);
                            b--;
                            continue;
                        }
                        else if (firstRoom == noone || is_undefined(firstRoom)){
                            firstRoom = secondRoom;
                        }
                        else if (secondRoom == noone || is_undefined(secondRoom)){
                            secondRoom = firstRoom;
                        }
                                                
                        var corridorsToAdd = gridCorridor(terrain, firstRoom, secondRoom, (TYPE_DIRT), corridorMinWidth-1, centeredCorridors);
                        
                        ds_list_add(newPairList, firstRoom); 
                        for (var c = 0; c &lt; ds_list_size(corridorsToAdd); c++){
                            var thisCorridor = ds_list_find_value(corridorsToAdd, c);
                            for (var d = thisCorridor[0]; d&lt;= thisCorridor[2]; d++){
                                for (var e = thisCorridor[1]; e &lt;= thisCorridor[3]; e++){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                                for (var e = thisCorridor[3]; e &gt;= thisCorridor[1]; e--){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                            }
                            
                            for (var d = thisCorridor[2]; d &gt;= thisCorridor[0]; d--){
                                for (var e = thisCorridor[3]; e &gt;= thisCorridor[1]; e--){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                                for (var e = thisCorridor[1]; e &lt;= thisCorridor[3]; e++){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                            }
                            for (var d = thisCorridor[2]; d&lt;= thisCorridor[0]; d++){
                                for (var e = thisCorridor[3]; e &lt;= thisCorridor[1]; e++){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                                for (var e = thisCorridor[1]; e &gt;= thisCorridor[3]; e--){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                            }
                            
                            for (var d = thisCorridor[0]; d &gt;= thisCorridor[2]; d--){
                                for (var e = thisCorridor[1]; e &gt;= thisCorridor[3]; e--){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                                for (var e = thisCorridor[3]; e &lt;= thisCorridor[1]; e++){
                                    var thisCluster = array(d, e, d, e);
                                    ds_list_add(finalCorridorList, thisCluster);
                                }
                            }
                        } 
                        ds_list_destroy(corridorsToAdd);
                    }
                    ds_list_clear(pairs);
                    
                    for (var b = 0; b &lt; ds_list_size(newPairList); b+=2){
                        thisNewPair = ds_list_create();
                        ds_list_add(thisNewPair, ds_list_find_value(newPairList, b));
                        ds_list_add(thisNewPair, ds_list_find_value(newPairList, b+1));
                        ds_list_add(pairs, thisNewPair);
                        ds_list_mark_as_list(pairs, ds_list_size(pairs)-1);
                    }   
                
                }
                toDestroy[array_length_1d(toDestroy)] = newPairList;
                toDestroy[array_length_1d(toDestroy)] = clusterList;
                toDestroy[array_length_1d(toDestroy)] = pairs;
            }
            else{
                step++;
                
            
                status = "Defining spawn area";
            }
            break;
            
        case 1:
            /// Spawning uplinker &amp; defining spawn
            log("SPAWNING UPLINKER", "MAPGENRT");
            
            // Let's make SURE there is a spawnroom
            if (spawnRoom == noone){
                log("Spawn room was not defined yet - Giving a random one and clearing it out", "MAPGENRT");
                var spawnIndex = irandom(ds_list_size(finalRoomList)-1);
                spawnRoom = finalRoomList[|spawnIndex];
                ds_grid_set_region(terrain, spawnRoom[0], spawnRoom[1], spawnRoom[2], spawnRoom[3], TYPE_DIRT);
                
                // rebuilding lava/water room lists so it doesn't conflict with spawn
                if (lava){
                    var newRooms = array(noone);
                    for (var i = 0; i &lt; array_length_1d(lavaRooms); i++){
                        var thisRoom = lavaRooms[i];
                        if (thisRoom != noone &amp;&amp; is_array(thisRoom) &amp;&amp; !array_equals(thisRoom, spawnRoom)){
                            if (newRooms[0] == noone){
                                newRooms[0] = thisRoom;
                            }
                            else{
                                newRooms[array_length_1d(newRooms)] = thisRoom;
                            }
                        }
                    }
                    lavaRooms = newRooms;
                }
            }
            border = 2;
            thisObjectChunk = object_game.firstBuilding;
            spawn = array(rrandom(spawnRoom[2]-spawnRoom[0]-border*2)+spawnRoom[0]+border,rrandom(spawnRoom[3]-spawnRoom[1]-border*2)+border+spawnRoom[1]);
            spawn = array(round(spawn[0]), round(spawn[1]));
            log("Exact spawn position is "+string(spawn));
            ds_grid_set(objects, spawn[0], spawn[1], thisObjectChunk);
            
            
            
            if (spawnScramblers){
                log("SPAWNING SCRAMBLERS", "MAPGENRT");
                for (var b = 0; b &lt; ds_list_size(finalRoomList); b++){
                    var thisRoom = finalRoomList[|b];
                    if (array_equals(thisRoom, spawnRoom)){
                        continue;
                    }
                    var scramblerPos = array(floor(mean(thisRoom[0], thisRoom[2])), floor(mean(thisRoom[1], thisRoom[3])));
                    
                    ds_grid_set(objects, scramblerPos[0], scramblerPos[1], object_electromagnetical_scrambler_explorer);                    
                }
            }
            
            h = 0;
            i = 0;
            j = 0;
            step++;
            status = "Filling places with dirt";
            break;
            
        case 2:
            /// Dirt fill
            log("FILLING EVERY PLACE WITH DIRT WALLS &amp; CLEARING LAVA", "MAPGENRT");
            
            
            for (var b = 0; b &lt; caveSize[0]; b ++){
                for (var c = 0; c &lt; caveSize[1]; c ++){
                    if (ds_grid_get(terrain, b, c) == TYPE_DIRT){
                        // cleaning lava
                        var skip = false;
                        for (var d = 1; d &lt; array_length_1d(lavaRooms); d++){
                            var laval = lavaRooms[d];
                            if (b &gt;= laval[0] &amp;&amp; b &lt;= laval[2] &amp;&amp; c &gt;= laval[1] &amp;&amp; c &lt;= laval[3]){
                                skip = true;
                                ds_grid_set(terrain, b, c, TYPE_LAVA)
                                break;
                            }
                        }
                        
                        if (!skip){
                            terrain_set_region(walls, b, c, b+1, c+1, TERRAIN_WALL_DIRT, true);
                        }
                    }
                }
            }
            
            status = "Carving rooms";
            
            step++;
            break;
            
        case 3:
            /// Visual walls to clear rooms from dirt
            
            var size = ds_list_size(finalRoomList);
            if (h &lt;size){
                status = "Carving rooms ("+string((h/(ds_list_size(finalRoomList)))*100)+"%)";
                var thisRandom = random(0.1)+roomClearAmount;
                var thisRoom = ds_list_find_value(finalRoomList, h);
                var middleX = round(thisRoom[2]-thisRoom[0])/2+thisRoom[0];
                var middleY = round(thisRoom[3]-thisRoom[1])/2+thisRoom[1];
                var roomSize = median((thisRoom[2]-thisRoom[0]), (thisRoom[3]-thisRoom[1]));
                
                for (var b = 0; b &lt; caveSize[0]; b ++){
                    for (var c = 0; c &lt; caveSize[1]; c ++){
                        
                        if (getType(array(b,c), terrain) == TYPE_DIRT &amp;&amp; 
                            ds_grid_get(walls,b,c) == TERRAIN_WALL_DIRT &amp;&amp;
                            (roomSize)*thisRandom &gt; point_distance(middleX, middleY, b, c)){
                            
                            createVisualWall(array(b,c), TERRAIN_WALL_CLEAR, walls, true);
                            
                        }
                        else if (getType(array(b,c), terrain) == TYPE_WATER  || getType(array(b,c), terrain) == TYPE_LAVA){
                            createVisualWall(array(b,c), TERRAIN_WALL_CLEAR, walls, true);
                        }
                        
                    }
                }
            h++;
            }
            else{
                h = 0;
                i = 0;
                j = 0;
                status = "Clearing spawn room";
            
                step++;
            }
            break;
            
        case 4:
            log("CLEARING SPAWN ROOM", "MAPGENRT");
            var thisRoom = spawnRoom;
            terrain_set_region(walls, thisRoom[0], thisRoom[1], thisRoom[2], thisRoom[3], TERRAIN_WALL_CLEAR, true);
                        
            step++;
            status = "Placing gravel";
            break;
            
        case 5:
            log("SPAWNING GRAVEL", "MAPGENRT");
            for (var i = 0; i &lt; caveSize[0]; i ++){
                for (var j = 0; j &lt; caveSize[1]; j ++){
                    
                    var thisObjectChunk = ds_grid_get(objects, i, j);
                    var thisWallChunk = ds_grid_get(walls, i, j);
                    var thisTerrainChunk = ds_grid_get(terrain, i, j);
                    
                    if (!isTypeSolid(thisTerrainChunk) &amp;&amp; 
                        (is_undefined(thisWallChunk) || thisWallChunk == TERRAIN_WALL_CLEAR) &amp;&amp;
                        (is_undefined(thisObjectChunk) || thisObjectChunk &lt; 0) &amp;&amp;
                        random(1) &lt; gravelFrequency
                        ){
                        ds_grid_set(gravel, i, j, genGravel());
                    }
                }
            }
                        
            step++;
            status = "Placing Hard rock";

            break;
            
        case 6:
            log("REPLACING ROCK WITH HARDROCK", "MAPGENRT");
            
            var distance =  min(maxHardrockDistance, (caveSize[0]+caveSize[1])/6);
            
            for (var i = 0; i &lt; caveSize[0]; i ++){
                for (var j = 0; j &lt; caveSize[1]; j ++){
                    var chance = random(1);
                    
                    if (ds_grid_get(walls, i,j) == TERRAIN_WALL_DIRT &amp;&amp; 
                        point_distance(i, j, spawn[0], spawn[1]) &gt; distance &amp;&amp;
                        chance &gt; hardrockFrequency){
                        ds_grid_set(walls, i, j, TERRAIN_WALL_HARDROCK);
                    }
                }
            }
            status = "Applying level stroke (1 of 2)";
                        
            step++;
            break;
            
        case 7:
            log("FILLING EVERY VOID WITH UNBREAKABLE", "MAPGENRT");
            for (var i = 0; i &lt; caveSize[0]; i ++){
                for (var j = 0; j &lt; caveSize[1]; j ++){
                    if (getType(array(i,j), terrain) == TYPE_VOID){
                        //show_debug_message(array(i,j));
                        createVisualWall(array(i,j), TERRAIN_WALL_UNBREAKABLE, walls, true);
                    }
                }
            }
            status = "Applying level stroke (2 of 2)";
                        
            step++;
            break;
        
        case 8:
            //HITBOXISATION OF THE LEVEL STROKE
            log("SPAWNING HITBOXES ON LEVEL STROKE", "MAPGENRT");
            for (var i = 0; i &lt; caveSize[0]; i ++){
                for (var j = 0; j &lt; caveSize[1]; j ++){
                
                    var thisTerrainChunk = ds_grid_get(terrain, i, j);
            
                    //testing all the sides
                    var nearTerrains = array(   ds_grid_get(terrain, clamp(i+1, 0, caveSize[0]-1), clamp(j, 0, caveSize[1]-1)),
                                            ds_grid_get(terrain, clamp(i-1, 0, caveSize[0]-1), clamp(j, 0, caveSize[1]-1)),
                                            ds_grid_get(terrain, clamp(i, 0, caveSize[0]-1), clamp(j+1, 0, caveSize[1]-1)),
                                            ds_grid_get(terrain, clamp(i, 0, caveSize[0]-1), clamp(j-1, 0, caveSize[1]-1)));
                    /*
                    var nearTerrains = array(ds_grid_get(terrain, (i+1), (j)),
                                            ds_grid_get(terrain, (i-1), (j)),
                                            ds_grid_get(terrain, (i), (j+1)),
                                            ds_grid_get(terrain, (i), (j-1)));
                    */
                    //endof
                    
                    if (isTypeSolid(thisTerrainChunk) &amp;&amp; (
                        !isTypeSolid((nearTerrains[0])) ||
                        !isTypeSolid((nearTerrains[1])) ||
                        !isTypeSolid((nearTerrains[2])) ||
                        !isTypeSolid((nearTerrains[3])))){
                        
                        ds_grid_set(objects, i, j, object_solid);
                    }
                    
                }
            }
            status = "Populating loot map";
                        
            step++;
            break;
            
        case 9:
            log("POPULATING LOOT MAP", "MAPGENRT");
            dirtList = ds_list_create();
            
            for (var i = 0; i &lt; caveSize[0]; i ++){
                for (var j = 0; j &lt; caveSize[1]; j ++){
                    if (ds_grid_get(terrain, i, j) == TYPE_DIRT){
                        ds_list_add(dirtList, array(i,j));
                    }
                }
            }
            
            log("Dirt list has a size of "+string(ds_list_size(dirtList)), "MAP_LOOT");
            
            status = "Generating veins";
                        
            step++;
            break;
            
        case 10:
            /// Picking a random dirt and making it the start of a filon
            fakeGrids = array(noone);
            for (var i = 0; i &lt; numberOfFilons; i++){
                fakeGrids[array_length_1d(fakeGrids)] = ds_grid_create(caveSize[0], caveSize[1]);
            }
            for (var i = 0; i &lt; numberOfFilons; i++){
                var fakeGrid = fakeGrids[i+1];
                var pick =  floor(ds_list_size(dirtList)* (0.1+0.8*(i/numberOfFilons)));
                var luckyDirt = dirtList[| pick];
                log("Luck dirt #"+string(i+1)+" is "+string(luckyDirt[0])+","+string(luckyDirt[1]), "MAP_LOOT");
                var range = floor(random(filonRange[0]) + filonRange[1]);
                
                ds_grid_clear(fakeGrid, 0);
                
                for (var j = range; j &gt;= filonRange[0]; j--){
                    //ds_grid_add_disk(fakeGrid, luckyDirt[0], luckyDirt[1], j, 1); Uncomment this for incremental richness of walls
                    ds_grid_set_disk(fakeGrid, luckyDirt[0], luckyDirt[1], j, 1);
                    log("For filon #"+string(i+1)+" : made disk of range "+string(j)+" on lucky dirt", "MAP_LOOT");
                }
            }
            h = 1;
            ds_list_destroy(dirtList);
            status = "Populating veins ("+string((h/(numberOfFilons+1))*100)+"%)";
            step++;
            break;
            
        case 11:
            status = "Populating veins ("+string((h/(numberOfFilons+1))*100)+"%)";
            if (h  &lt; numberOfFilons+1){
                var debugString = "";
                var fakeGrid = fakeGrids[h];
                
                var thisFilon = filons[h-1];
                for (var i = 0; i &lt; caveSize[0]; i ++){
                    for (var j = 0; j &lt; caveSize[1]; j ++){
                        var amount = ds_grid_get(fakeGrid, i, j);
                        debugString += string(amount)+" ";
                        if (amount &lt;= 0){
                            continue;
                        }
                        var map = ds_grid_get(loot, i, j);
                        if (!ds_exists(map, ds_type_map)){
                            map = ds_map_logcreate();
                        }
                        if (is_undefined(map [? thisFilon])){
                            map [? thisFilon] = 0;
                        }
                        map[? thisFilon] += amount;
                        ds_grid_set(loot, i, j, map);
                    }
                    debugString+='|';
                }
                log("Filon of "+string(thisFilon)+":
            |"+debugString, "MAP_LOOT", "FILON#"+string(h)+".LOG");
            
                ds_grid_destroy(fakeGrids[h]);
                h++;
            }
            else{
                status = "End of generation - initializing";
                step++;
                h = 0;
            }
            break;
            
        case 12:
            
            global.terrain = terrain;
            global.terrain_loot = loot;
            global.terrain_objects = objects;
            global.terrain_walls = walls;
            global.terrain_gravel = gravel;
            global.terrain_walls_tiles[0,0] = noone;
                        
            log("END OF GENERATION - INITIALIZING", "MAPGENRT");
            
            finished = true;
            step = 0;
            break;
    }
    //finished = true;
}
else if (!initialized){ 
    
    switch (step){
        
        case 0:
            room_goto(global.gameRoom);
            object_game.menuing = false;
            status = "Initializing vision grid";
            step++;
            break;
            
        case 1:
            initializeVisionman(caveSize);
            status = "Initializing ground modifiers";
            step++;
            break;
            
        case 2:
            initializeGravelman(caveSize);
            status = "Initializing walls grid";
            step++;
            break;
            
        case 3:
            initializeDrillman(caveSize, buildingLootMultiplier)
            status = "Initializing objects";
            step++;
            break;
            
        case 4:
            initializeGridman(caveSize);
            status = "Updating vision grid";
            step++;
            break;
        
        case 5:
            refreshVision();
            status = "Initializing tiles";
            step++;
            break;
        
        case 6:
            for(var i=0; i&lt;caveSize[0]; i++) {
                for(var j=0; j&lt;caveSize[1]; j++){
                    terrain_add_tile(i,j,global.terrain_walls,32,caveSize[0],caveSize[1],global.terrain_walls[# i,j])
                }
            }
            status = "End of initialization";
            
            step++;
            break;
            
        case 7:
            timer = (get_timer()-timer)/1000000;
            
            clearVision();
            var ul = instance_find(object_game.firstBuilding, 0);
            instance_create(ul.x, ul.y, object_vision_explorer);
            log("Succesfully finished map creation in "+string(timer)+" seconds.");
            bgsFade(getWorld(global.currentCave[? CAVE_WORLD], WORLD_BGS));
            bgmFade(choose(sound_bgm_ingame_1, sound_bgm_ingame_2, sound_bgm_ingame_3));
            object_game.pausing = false;
            initialized = true;
            step++;
            
            if (!checkMarker("quickstart")){
                var window = createWindow(
                    translate("GENERAL_UI", "notice"),
                    translate("MARKERS", "quickstart")
                    );
                validateMarker("quickstart");
                window.wasMenuing = false;
            }
            else{
                loaderWindow.wasMenuing = false;
                loaderWindow.hostWindow.wasMenuing = false;
            }
            break;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vx = view_xview;
var vy = view_yview;
var h = view_hview;
var w = view_wview;


if (finished &amp;&amp; initialized &amp;&amp; debug){
    if (instance_exists(loaderWindow)){
        loaderWindow.die = true;
    }
    draw_set_color(c_black);
    draw_rectangle(vx, vy, vx+w, vy+h, false);
    
    if (keyboard_check_pressed(vk_right) &amp;&amp; debugIndex &lt; array_length_1d(debugDisplay)-1){
        debugIndex++;
    }
    if (keyboard_check_pressed(vk_left) &amp;&amp; debugIndex &gt; 0){
        debugIndex--;
    }
    
    var td = debugDisplay[debugIndex];
    var grid = noone;
    switch (td){
        case "terrain":
            grid = terrain;
            break;
        case "objects":
            grid = objects;
            break;
        case "walls":
            grid = walls;
            break;
        case "gravel":
            grid = gravel;
            break;
        case "loot":
            grid = loot;
            break;
    }
    status+= "#Debugging "+td;
    var size = array(ds_grid_width(grid), ds_grid_height(grid));
    var blockSize = array(
        (w-1)/(size[0]),
        (h-1)/(size[1])
    );
    for (var i = 0; i &lt; size[0]; i++){
        for (var j = 0; j &lt; size[1]; j++){
            var block = array(vx+i*blockSize[0], vy+j*blockSize[1], vx+(i+1)*blockSize[0], vy+(j+1)*blockSize[1]);
            var bg = make_colour_hsv(ds_grid_get(grid, i, j)*25, 130, 130);
            draw_set_color(bg);
            draw_rectangle(block[0], block[1], block[2], block[3], false);
        }
    }
        
    draw_set_valign(fa_middle);
    draw_set_halign(fa_center);
    draw_set_font(font_ui);
    
    drawShadowedText(vx+w/2, vy+h/2, loadingText+"#"+status);
}

/*

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
