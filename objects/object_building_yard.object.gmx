<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_wall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>depth = -(x + y);

var pos = snapToGrid(array(x+G_CELLSIZE/2,y+G_CELLSIZE/2));
x = pos[0];
y = pos[1];

dead = false;

fakeX = x+G_CELLSIZE/2;
fakeY = y+G_CELLSIZE/2;

ownIsoIndex = array(x/G_CELLSIZE, y/G_CELLSIZE);

firstStep = true;
skin = sprite_building_yard;
animIndex = 0;

mustLiberate = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var fund = getYardFunds(id);
var needs = getYardNeeds(id);
var ressources = getBuildingMaterials();


if (mustLiberate){
    //RESSOURCE LIBERATION ON YARD OPENING
    mustLiberate = false;
    var yards = getYards();
    
    //SIZE CALCULATION
    var objective = getYardObjective(id);
    var size = getBuilding(objective, "size");
    image_xscale = size;
    image_yscale = size;
    
    //0) CALCULATE THE NEEDS
    //calculate needs for EVERY YARD
    
    var myNeeds = ds_map_logcreate();                          /// 1
    for (var i = 0; i &lt; ds_list_size(yards); i++){
        var thisYard = ds_list_find_value(yards, i);
        thisYard = ds_map_find_value(thisYard, "buildingObject");
        var thisNeeds = getYardNeeds(thisYard);
        for (var j = 0; j &lt; array_length_1d(ressources); j++){
            var actualNeeds = ds_map_find_value(thisNeeds,  ressources[j]);
            
           if (ds_map_exists(myNeeds,  ressources[j])){
                ds_map_replace(myNeeds, ressources[j], ds_map_find_value(myNeeds, ressources[j]) + actualNeeds);
           }
           else{
                ds_map_add(myNeeds, ressources[j], actualNeeds);
           }
        }
    }
    
    //1) Calculate which toolstore is the nearest from the yard
    
    var distances = ds_list_create();                       /// L1
    var toolstoreMap = ds_map_logcreate();                     /// M2
    
    for (var i = 0; i &lt; instance_number(object_building_stocker); i++){
        var thisTS = instance_find(object_building_stocker, i);
        if (canGoToBuilding(thisTS)){
            var path = getPathToBuilding(thisTS);
            var length = path_get_length(path);
            ds_list_add(distances, length);
            ds_map_add(toolstoreMap, length,thisTS);
        }
        else{
            continue;
        }
    } 
    
    
    
    /// Should not happen, but still...
    ds_list_sort(distances, true);
    if (ds_list_size(distances) &lt;= 0){
        ds_list_destroy(distances);
        ds_map_logdestroy(toolstoreMap);
        ds_map_logdestroy(myNeeds);
        exit;
    }
    var nearest = ds_map_find_value(toolstoreMap, ds_list_find_value(distances, 0));
       
    ds_list_destroy(distances);
    ds_map_logdestroy(toolstoreMap);   
    
    //2) account available ressources on the field
    var rsc = getBuildingMaterials();
    for (var i = 0; i &lt; array_length_1d(rsc); i++){
        var thisRsc  = getRessource(rsc[i], "object");
        var thisNeed = ds_map_find_value(myNeeds, rsc[i]);
        if (is_undefined(thisNeed)){
            thisNeed = 0;
        }
        var rscOnField = 0;
        for (var j = 0; j &lt; instance_number(thisRsc); j ++){
            var thisInst = instance_find(thisRsc, i);
            if (instance_exists(thisInst) &amp;&amp; thisInst.visible &amp;&amp; canGo(array(thisInst.x, thisInst.y))){
                rscOnField ++;
            }
        }
        ds_map_replace(myNeeds, rsc[i], max(0, thisNeed-rscOnField));
    }
    
    //3) Liberate enough ressources to the extent of the possible  
    
    liberateRsc(myNeeds, nearest);
    ds_map_logdestroy(myNeeds);
}



var completedRessources = 0;
var neededRessources = 0;

for (var i = 0; i &lt; array_length_1d(ressources); i++){
    var tFund = ds_map_find_value(fund, ressources[i]);
    var tNeeds = ds_map_find_value(needs, ressources[i]);
    if (tFund &gt;= tNeeds){
        completedRessources++;
    }
    if (tNeeds &gt; 0){
        neededRessources++;
    }
}

if (neededRessources == completedRessources){
    for (var i = 0; i &lt; array_length_1d(ressources); i++){
        var object = getRessource(ressources[i], "object");
        with (object){
            if (partOfBuilding == other.id){
                instance_destroy();
            }
        }
    }
    var finalBuilding = instance_create(x,y,getYardObjective(id));
    finalBuilding.arriving = true;
    remYard(id);
    if (finalBuilding.object_index == object_ground_pathway){
        addToStat('pathwaysBuilt', 1);
    }
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var drawPos = sysToDisplay(array(x,y));
animIndex = (animIndex + 1.25*(1/room_speed))%sprite_get_number(skin);
draw_set_color(c_aqua);

if (object_debug.orthographic){
    draw_rectangle(x, y, x+G_CELLSIZE, y+G_CELLSIZE, false);
}
else{
    var objective = getYardObjective(id);
    var size = getBuilding(objective, "size");
    if (size &gt; 1){
        var spread = growToRoom(array(x/G_CELLSIZE, y/G_CELLSIZE), size);
        for (var i = spread[0]; i &lt; spread[2]; i++){
            for (var j = spread[1]; j &lt; spread[3]; j++){
                drawPos = sysToDisplay(array(i*G_CELLSIZE,j*G_CELLSIZE));
                draw_sprite(skin, animIndex, drawPos[0], drawPos[1]);
            }
        }
    }
    else{
        draw_sprite(skin, animIndex, drawPos[0], drawPos[1]);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
