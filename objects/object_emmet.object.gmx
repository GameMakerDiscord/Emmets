<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_emmet_idle_back</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//VARS

refreshPathfinder();

spriteToDraw = sprite_index;
animSpeed = 10;
moveSpeed = 0.5;
maxHp = 100;
eid = 0;        /// Unique EMMET ID

name = "";
color = c_white;
alpha = 1;

//Equip
equipments = ds_list_create();
ds_list_add(equipments, EQUIPMENT_SHOVEL, EQUIPMENT_DRILL);
maxEquipments = 2;

//Training
trainings = ds_list_create();

trainingCentre = noone;
trainingGauge = 0;
trainingSpeed = 0.2;

//IAI
chosenToThink = false;
debugIAI = false;
debugger = noone;

//Objectives
willDo = noone;
willType = noone;
pickDistance = 12;

//Holding
holding = noone;

//Gravelclear
onClearTimer = 0; //counter;
clearEvery = 0.3; //seconds he's gonna remove 10 HP
isClearing = false;
willClear = array(0,0);
currentClearSound = sound_void;

//Drilling
onDrillTimer = 0; //counter;
drillEvery = 0.3; //seconds he's gonna remove 10 HP
isDrilling = false;
willDrill = array(noone, noone);
currentDrillSound = sound_void;

//Dynamiting
willDynamite = array(noone, noone);
dynamiteObjective = array(noone, noone);

//Misc
facing = 270;
idle = false;
humor = HUMOR_MOVING;
depositDistance = G_CELLSIZE;
dynamiteDistance = 4;
drillDistance = 2;

//COUNTERS

animIndex = 0;
path = path_add();
old = array(0, 0);
oldDraw = array(0, 0);
solving = false;
actHp = maxHp;

//DEAD
destroy = false;
dead = false;
deadEmitter = noone;
deadIncrement = 0;

//ARRIVING
arriving = false;
timerOfArrival = 0; //will redux

/// Trainings var
geoEvery = 5; /// every 3 seconds
geoTimer = 0;
geoPulse = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if instance_exists(debugger){
    with (debugger){
        instance_destroy();
    }
}
extractEmmet(eid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///depth


depth = -(x + y);
offSightMask();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///arriving (exit)
if (arriving){ 
    unSelectEmmet(id);
    path_end();
    timerOfArrival -= 1/room_speed;
    if (timerOfArrival &lt;= 0){
        arriving = false;
        if (!checkMarker("emmets")){
            createWindow(
                translate("GENERAL_UI", "notice"),
                translate("MARKERS", "emmets")
                );
            validateMarker("emmets");
        }
    }
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///destroy(exit)
if (destroy){
    if (dead != true){
        animIndex = 0;
        unSelectEmmet(id);
        emmetDropObject(id);
        path_end();
        destroyCrewMember(eid);
        dead = true;
    }
    humor = HUMOR_DEAD;
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///dead (exit)
if (dead){ 
    humor = HUMOR_TELEPORT;
    unSelectEmmet(id);
    path_end();
    emmetDropObject(id);
    direction = 135;
    speed *= 1;
    deadIncrement++;
    alpha -= (deadIncrement/300);
    if (!instance_exists(deadEmitter)){
        deadEmitter = instance_create(x, y, object_teleporter_fx);
        deadEmitter.width = 10;
        deadEmitter.particleColor = c_aqua;
        deadEmitter.followObject = id;
        deadEmitter.particleAlphaDropSpeed = 10;
        deadEmitter.yCorrection = 8;
        playSfx(sound_sfx_recall, false, id);
    }
    else{
        deadEmitter.particleAlphaMul = 1-(deadIncrement/30);
        deadEmitter.particleSize = 4+(deadIncrement*3)/60;
    }
    if(deadIncrement/60 &gt; 0.5){
        with deadEmitter{
            instance_destroy();
        }
        instance_destroy();
    }
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Main functionnality
debugIAI = object_debug.debugOptions[? "debugIAI"];
if ((debugIAI) &amp;&amp; !instance_exists(debugger)){
    debugger = instance_create(0,0,object_debug_IAI_probe);
    debugger.target = id;
}
else if (!debugIAI &amp;&amp; instance_exists(debugger)){
    instance_destroy(debugger);
}

/// SPEED CALCULUS
var realSpeed = moveSpeed;
var ownIsoIndex = array(round((x-G_CELLSIZE/2)/G_CELLSIZE), round(((y-G_CELLSIZE/2)/G_CELLSIZE)));

if (holding &gt; 0 &amp;&amp; instance_exists(holding)){
    realSpeed *= holding.weightFactor;
}
var pos = snapToGrid(array(x, y));
pos = array(floor(pos[0]/G_CELLSIZE), floor(pos[1]/G_CELLSIZE));
var col = onChunk(pos, object_ground);
if (instance_exists(col)){
    realSpeed *= col.speedFactor;
}
else if (getGravel(pos) != noone){
    realSpeed *= GRAVEL_SPEED_REDUX;
}
path_speed = realSpeed;

/// BEHAVIOR
if (!object_game.paused){

    /// Dead if no HP left
    if (actHp &lt;= 0){
        destroy = true;
        exit;
    }
    if ( mp_grid_get_cell(global.grid, x div G_CELLSIZE, y div G_CELLSIZE) == -1){
        dead = true;
        exit;
    }
    
    ///////////
    ///
    ///  TRAINING BEHAVIOR
    ///
    
    adoptTrainingBehavior(id);
    
    //////////
    ///
    /// MOVEMENT WHEN SELECTED, ON RIGHT CLICK
    ///
    /////////
    if (isSelectedEmmet(id)){
        
        /// RIGHT CLICK =&gt; ACTION
        if (global.i[I_ACTION]){
        
            /// Stop what emmet is doing
            var sCX = displayToSysX(global.i[I_X], global.i[I_Y]);    
            var sCY = displayToSysY(global.i[I_X], global.i[I_Y]);    
            path_end();
            isDrilling = false;
            isClearing = false;
            willType = noone;
            
            var pointingPickable = noone;
            for (var i = 0; i &lt; instance_number(object_pickable); i++){
                var inst = instance_find(object_pickable, i);
                if (point_distance(inst.x, inst.y, sCX, sCY) &lt; pickDistance){
                    if (pointingPickable == noone || point_distance(inst.x, inst.y, sCX, sCY) &lt; point_distance(pointingPickable.x, pointingPickable.y, sCX, sCY)){
                        pointingPickable = inst;
                    }
                }
            }
            
            /// Cursor on pickable : Pick it
            if (instance_exists(pointingPickable)){
                willDo = pointingPickable;
                willType = WILL_PICK;
            }              
            
            /// Cursor on wall : Drill it
            else if (getWallMap(object_gridman.cursorIsoIndex) != false &amp;&amp; isVisible(object_gridman.cursorIsoIndex)){
            
                willDrill = object_gridman.cursorIsoIndex;
                if (canDrill(id, willDrill)){
                    // drop object
                    emmetDropObject(id);
                    willType = WILL_DRILL;
                    blinkWall(willDrill);
                }
                else{
                    willDrill = array(noone, noone);
                    willDo = noone;
                }
            }
            
            /// Cursor on gravel : Clear it
            else if (getGravel(object_gridman.cursorIsoIndex) != noone &amp;&amp; isVisible(object_gridman.cursorIsoIndex)){
                // drop object
                emmetDropObject(id);
                willClear = object_gridman.cursorIsoIndex;
                willType = WILL_CLEAR;
                blinkGravel(willClear);
            }
            
            /// Cursor on ground : Go to it
            else if (isOnGameScreen(global.i[I_X], global.i[I_Y]) &amp;&amp; !isTypeSolid(getType(object_gridman.cursorIsoIndex))){
                willType = noone;
                var iX = global.i[I_X];
                var iY = global.i[I_Y];
                var cfx = instance_create(iX, iY, object_crossmarker_fx);
                cfx.color = c_lime;
                if (object_debug.orthographic){
                    pathTo(array(global.i[I_X], global.i[I_Y]), realSpeed);
                }
                else{
                    pathTo(displayToSys(array(global.i[I_X],global.i[I_Y])), realSpeed);
                }
            }
        }
    }
    
    
    ////////////////////
    ///
    /// Following orders
    ///
    ////////////////////
    if (willType != noone){
        switch (willType){
    //Picks willPick
            case WILL_PICK:
                if (instance_exists(willDo) &amp;&amp; isTrainedToPick(willDo)){
                    if (willDo.pickedUp != noone || 
                        !isTrainedToPick(willDo)){ 
                        path_end();
                        willDo = noone;
                        willType = noone;
                    }
                    else{ 
                        pathTo(array(willDo.x, willDo.y), realSpeed);
                        if (position_meeting(x, y, willDo) &amp;&amp; isTrainedToPick(willDo)){
                            holding = willDo;
                            willDo.pickedUp = id;
                            
                            if (instance_exists(willDo.partOfBuilding)){
                                var thisYard = willDo.partOfBuilding;
                                var cFund = getYardFunds(thisYard);
                                var rsc = getRessourceFromObject(willDo.object_index);
                                ds_map_replace(cFund, 
                                                rsc, 
                                                ds_map_find_value(cFund, rsc)-1);
                                updateYard(thisYard, cFund);
                            }
                            
                            willDo.partOfBuilding = noone;
                            willDo = noone;
                            
                            if (holding.object_index == object_pickable_dynamite){
                                willType = WILL_DYNAMITE;
                            }
                        }
                    }
                }
                else{
                    willType = noone;
                }
                break;
    //Endof
    
    //Clear gravel
            case WILL_CLEAR:
                if (getGravel(willClear) != noone &amp;&amp; hasEquipment(EQUIPMENT_SHOVEL)){
                    var pos = array(floor(x/G_CELLSIZE), floor(y/G_CELLSIZE));
                    
                    var gravelImOn = getGravel(pos);
                    if (gravelImOn != noone &amp;&amp; 
                        pos[0] == willClear[0] &amp;&amp; 
                        pos[1] == willClear[1]){
                        
                        onClearTimer += (1+random(0.5))/(room_speed);
                        isClearing = true;
                        path_end();
                        if (onClearTimer &gt; clearEvery){
                            onClearTimer = 0;
                            damageGravel(willClear, 10);
                        }
                    }
                    else if (old[1] == y &amp;&amp; old[0] == x){
                        onClearTimer = 0;
                        var gravelPos = array(willClear[0]*G_CELLSIZE, willClear[1]*G_CELLSIZE);
                        pathTo(array(gravelPos[0]+G_CELLSIZE/2, gravelPos[1]+G_CELLSIZE/2), realSpeed);
                    }
                }
                else{
                    willClear = array(0,0);
                    willType = noone;
                    isClearing = false;
                    onClearTimer = 0;
                }
                break;
    //Endof
    
    //Drill Wall
            case WILL_DRILL:
                
                if (getWallMap(willDrill) != false &amp;&amp; hasEquipment(EQUIPMENT_DRILL)){
                    var wallPos = array(willDrill[0]*G_CELLSIZE, willDrill[1]*G_CELLSIZE);
                    var objective = array(wallPos[0]+G_CELLSIZE/2, wallPos[1]+G_CELLSIZE/2);
                    var dir = point_direction(objective[0], objective[1], x, y);
                    dir = round(dir/90)%4;
                    for (var i = 0; i &lt; 4; i++){
                        var fakeO = array(noone, noone);
                        switch ((dir+i)%4){
                            case 1:
                                fakeO = array(objective[0], objective[1] - G_CELLSIZE*0.6);
                                break;
                            case 2:
                                fakeO = array(objective[0] - G_CELLSIZE*0.6, objective[1]);
                                break;
                            case 3:
                                fakeO = array(objective[0], objective[1] + G_CELLSIZE*0.6);
                                break;
                            case 0:
                                fakeO = array(objective[0] + G_CELLSIZE*0.6, objective[1]);
                                break;
                        }
                        var anypath = path_add();
                        if (mp_grid_path(global.grid, anypath, x, y, fakeO[0], fakeO[1], true)){
                            objective = fakeO;
                            break;
                        }
                    }
                    
                    if (old[1] == y &amp;&amp; old[0] == x &amp;&amp; !isDrilling){
                        onDrillTimer = 0;
                        pathTo(array(objective[0], objective[1]), realSpeed);
                    }
                    else if (point_distance(objective[0], objective[1], x, y) &lt; drillDistance){
                        onDrillTimer += (1+random(0.5))/(room_speed);
                        isDrilling = true;
                        path_end();
                        if (onDrillTimer &gt; drillEvery){
                            onDrillTimer = 0;
                            var wallActHp = ds_map_find_value(getWallMap(willDrill), "hp");
                            ds_map_replace(getWallMap(willDrill), "hp", wallActHp-10);
                            wallActHp = ds_map_find_value(getWallMap(willDrill), "hp");
                            if (wallActHp &lt;= 0){
                                destroyWall(willDrill);
                                addToStat("wallsDrilled", 1);
                            }
                        }
                    }
                }
                else{
                    willType = noone;
                    isDrilling = false;
                    onDrillTimer = 0;
                }
                
                break;
    //Endof
    
            ///WILL DYNAMITE
            
            case WILL_DYNAMITE:
                if (hasTraining(TRAINING_DYNAMITE)){
                    if (instance_exists(holding)){
                        if (holding.object_index == object_pickable_dynamite){
                            
                            if (willDynamite[0] == noone){
                                
                                dynamiteObjective = array(noone, noone);
                                var myObjectives = getWallToDynamiteList();
                                var size = ds_list_size(myObjectives);
                                if (size &gt; 0){
                                                    
                                    var queue = ds_list_create();
                                    var objectivesMap = ds_map_logcreate();
                                    for (var j = 0; j &lt; size ; j ++){
                                        var thisObjective = ds_list_find_value(myObjectives, j);
                                        if (getWallMap(thisObjective) != false){
                                            var distance = point_distance(thisObjective[0]*G_CELLSIZE, thisObjective[1]*G_CELLSIZE, x, y);
                                            ds_list_add(queue, distance);
                                            ds_map_add(objectivesMap, distance, thisObjective);
                                        }
                                    }
                                    
                                    ds_list_sort(queue, true);
                                    var queueSize = ds_list_size(queue);
                                    
                                    for (var j = 0; j &lt; queueSize; j++){
                                        var thisObjectiveFromQueue = ds_list_find_value(queue, j);
                                        var thisObjectiveFromMap = ds_map_find_value(objectivesMap, thisObjectiveFromQueue);
                                        
                                        
                                        if (!is_undefined(thisObjectiveFromMap)){
                                        
                                            willDynamite = thisObjectiveFromMap;
                                            
                                            with (object_emmet){
                                                if ((willDynamite[0] == other.willDynamite[0] &amp;&amp; willDynamite[1] == other.willDynamite[1]) &amp;&amp; id != other.id){
                                                    
                                                    other.willDynamite = array(noone, noone);
                                                }
                                            }
                                            
                                            if (willDynamite[0] != noone){
                                                break;
                                            }
                                        }
                                    }
                                    
                                }
                            }
                            else if (dynamiteObjective[0] == noone){
                                var anypath = path_add();
                                var objective = array(
                                                        willDynamite[0]*G_CELLSIZE+G_CELLSIZE/2, 
                                                        willDynamite[1]*G_CELLSIZE+G_CELLSIZE/2
                                                    );
                                var objectives = array(
                                                    array(objective[0], objective[1] - G_CELLSIZE*0.7),
                                                    array(objective[0] - G_CELLSIZE*0.7, objective[1]),
                                                    array(objective[0], objective[1] + G_CELLSIZE*0.7),
                                                    array(objective[0] + G_CELLSIZE*0.7, objective[1]));
                                
                                for (var i = 0; i &lt; array_length_1d(objectives); i++){
                                    var thisObj = objectives[i];
                                    if (mp_grid_path(global.grid, anypath, x, y, thisObj[0], thisObj[1], true)){                                
                                        dynamiteObjective = thisObj;
                                        break;
                                    }
                                }
                                if (dynamiteObjective[0] == noone){
                                    unmarkWallToDynamite(willDynamite);
                                    log("Unmarked wall "+string(objective)+" to dynamite cause there was no pathfinding to it", "EMMMET_WD");
                                    clearWallMarkers(willDynamite);
                                    with (holding){
                                        instance_destroy();
                                    }
                                    willDynamite = array(noone, noone);
                                    willType = noone;
                                }
                                
                            }
                            else{
                            
                                if (old[0] == x &amp;&amp; old[1] == y){
                                    pathTo(dynamiteObjective, realSpeed);
                                }
                                if (point_distance(x, y, dynamiteObjective[0], dynamiteObjective[1]) &lt; dynamiteDistance){
                                    with holding{
                                        instance_destroy();
                                    }
                                    emmetDropObject(id);
                                    
                                    unmarkWallToDynamite(willDynamite);
                                    revertWallColor(willDynamite);
                                    var td = instance_create(x,y, object_triggered_dynamite);
                                    td.target = willDynamite;
                                    willType = noone;
                                }
                            }
                        }
                        else{
                            emmetDropObject(id);
                        }
                    }
                }
                else{
                    willDo = noone;
                    willType = noone;
                }
                break;
                
            //ENDOF
        
        }
    }
    else{
        /// IDLE RESET (no will)
        
        willClear = array(0,0);
        willDrill = array(noone, noone);
        willDynamite = array(noone, noone);
        dynamiteObjective = array(noone, noone);
        willDo = noone;
        isDrilling = false;
        isClearing = false;
        trainingGauge = 0;
    }
    
    // Positions the held object
    if (instance_exists(holding)){
        var cx = 0;
        var cy = 3;
        holding.x = x;
        holding.y = y;
    }
    else{
        emmetDropObject(id);
    }
    //Endof
    
    ///////////////////
    ///
    /// "Collisions" with other emmets 
    ///
    if (place_meeting(x, y, object_index) &amp;&amp; old[1] == y &amp;&amp; old[0] == x &amp;&amp; !solving &amp;&amp; !isClearing &amp;&amp; !isDrilling &amp;&amp; willType == noone){
        pathTo(array(x+(random(4)-2), y+(random(4)-2)), max(moveSpeed, realSpeed));
        solving = true;
    }
    else if (old[1] == y &amp;&amp; old[0] == x ){
        solving = false;
    }
    
    if (!solving &amp;&amp; willType == noone &amp;&amp; !isSelectedEmmet(id)){
        idle = true;
    }
    else{
        idle = false;
    }
    
    ////////////////
    ///
    ///     HUMOR
    ///
    var dyna = instance_nearest(x, y, object_triggered_dynamite);
    if (instance_exists(dyna) &amp;&amp; point_distance(dyna.x, dyna.y, x, y) &lt; G_CELLSIZE){
        humor = HUMOR_AFRAID;
    }
    else if (willType == WILL_CLEAR){
        humor = HUMOR_CLEARING_GRAVEL;
    }
    else if (willType == WILL_DRILL){
        humor = HUMOR_DRILLING;
    }
    else if (willType == WILL_DYNAMITE){
        humor = HUMOR_DYNAMITE;
    }
    else if (willType == WILL_PICK){
        humor = HUMOR_PICKING_STUFF;
    }
    else if (old[1] != y || old[0] != x){
        humor = HUMOR_MOVING;
    }
    /*
    else if (isSelectedEmmet(id)){
        humor = HUMOR_HAPPY
    }
    */
    else if (idle){
        humor = HUMOR_SLEEPING;
    }
    
    
/////////////////////////////////////////////////
///                 SOUND                     ///
////////////////////////////////////////////////
    var drillSound = sound_sfx_drill;
    if (isDrilling){
        if (!audio_is_playing(currentDrillSound)){
            currentDrillSound = playSfx(drillSound, true, id, true, 1, true);
        }
    }
    else{
        if (audio_is_playing(currentDrillSound)){
            audio_stop_sound(currentDrillSound);
            currentDrillSound = sound_void;
        }
    }
    
    var clearSound = sound_sfx_clear_gravel;
    if (isClearing){
        if (!audio_is_playing(currentClearSound)){
            currentClearSound = playSfx(clearSound, true, id, true, 1, true);
        }
    }
    else{
        if (audio_is_playing(currentClearSound)){
            audio_stop_sound(currentClearSound);
            currentClearSound = sound_void;
        }
    }
    
    
    
/////////////////////////////////////////////////
///                 IDLE AI                  ///
////////////////////////////////////////////////

        
    
    if (idle &amp;&amp; (chosenToThink || getSetting("fastIAI"))){
        chosenToThink = false;
        if (debugIAI) debugger.text += "#WT : "+string(willType);
        
        var priorities = getSetting("priorities");
        
        for (var h = 0; h &lt; ds_list_size(priorities); h++){
            var currentPrio = ds_list_find_value(priorities, h);
            
            if (currentPrio == PRIORITY_BUILD){
                //////////////////
                ///BUILDING CONSTRUCTION
                //////////////////
                
                if (debugIAI) debugger.timers[? "BUILD"] = get_timer();
                
                //For each yard
                for (var hbis = 0; hbis &lt; ds_list_size(object_buildman.buildingList); hbis++){//for each buliding
                    
                    var firstBuild = ds_list_find_value(object_buildman.buildingList, hbis); 
                    
                    var needs = ds_map_find_value(firstBuild, "needs");
                    var cFund = ds_map_find_value(firstBuild, "currentFunds");
                    var buildingObject = ds_map_find_value(firstBuild, "buildingObject");
                    var ressourcesArr = getBuildingMaterials();
                    var workedIt = true;
                    
                    if (is_undefined(buildingObject) ||
                        is_undefined(needs) || 
                        is_undefined(cFund) ||
                        !instance_exists(buildingObject) || 
                        !ds_map_find_value(firstBuild, "buildingObjective") || 
                        !canGoToBuilding(buildingObject)){
                        if (debugIAI) debugger.text+="#BUILD: Yard is unreachable or no yard";
                        if (debugIAI) debugger.text+="#BUILD: Details : "+"-"+string(needs)+"-"+string(cFund)+"-"+string(buildingObject);
                        continue;       //Forget it if we cannot reach it
                    }
                    
                    for (var i = 0; i &lt; array_length_1d(ressourcesArr); i++){ //For each ressource, let's check if it has enough
                    
                        if (!instance_exists(getRessource(ressourcesArr[i], "object")) || 
                            is_undefined(needs[? ressourcesArr[i]]) || 
                            is_undefined(cFund[? ressourcesArr[i]])
                            ){
                            continue;
                        }
                    
                        var realCost = ds_map_find_value(needs, ressourcesArr[i]);
                        var currentFoundation =  ds_map_find_value(cFund, ressourcesArr[i]);
                        var neededRessourceAmount = realCost - currentFoundation;
                        
                        if (!is_undefined(neededRessourceAmount) &amp;&amp; neededRessourceAmount &gt; 0 &amp;&amp; instance_exists(buildingObject)){ //If this ressource is needed...
                            var ressourceNeeded = getRessource(ressourcesArr[i], "object");
                            
                            var gonnaSetI = array_length_1d(ressourcesArr); /////////////LOOP BREAKER PREPARATION
                            
                            //IF ALREADY HOLDING IT AND ON THE RIGHT PLACE TO PUT IT DOWN
                            
                            var buildingChunks = growToRoom(buildingObject.ownIsoIndex, getBuilding(getYardObjective(buildingObject), "size"));
                            var onDestination = false;
                            if (instance_exists(holding) &amp;&amp; holding.object_index == ressourceNeeded){
                                for (var j = buildingChunks[0]; j &lt; buildingChunks[2]; j++){
                                    for (var k = buildingChunks[1]; k &lt; buildingChunks[3]; k++){
                                        var pos = array(j, k);
                                        if (pos[0] == ownIsoIndex[0] &amp;&amp; pos[1] == ownIsoIndex[1]){
                                            onDestination = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (onDestination){
                                    if (debugIAI) debugger.text+="#BUILD : On destination";
                                //already good ? then drop it
                                    holding.partOfBuilding = buildingObject;
                                    emmetDropObject(id);
                                    ds_map_replace(cFund, ressourcesArr[i], ds_map_find_value(cFund, ressourcesArr[i])+1);
                                    updateYard(buildingObject, cFund);
                                    
                                h = ds_list_size(priorities); ///// LOOP BREAKER
                            }
                            //IF ALREADY HOLDING IT BUT NOT YET ON YARD
                            else  if (instance_exists(holding) &amp;&amp; holding.object_index == ressourceNeeded){
                                    if (debugIAI) debugger.text+="#BUILD : Going to the yard";
                                //Then go to the yard
                                if (old[1] == y || old[0] == x){
                                    pathTo(array(buildingObject.x+G_CELLSIZE/2, buildingObject.y+G_CELLSIZE/2), realSpeed);
                                }
                                h = ds_list_size(priorities); ///// LOOP BREAKER
                            } 
                            //IF MY OBJECTIVE EXISTS IN THIS WORLD
                            else if (!instance_exists(holding) &amp;&amp; instance_exists(ressourceNeeded)){
                                
                                    if (debugIAI) debugger.text+="#BUILD : Going to fetch the resource"
                                for (var j = 0; j &lt; instance_number(ressourceNeeded); j++){
                                    var rscObj = instance_nth_nearest(x,y,getRessource(ressourcesArr[i], "object"), j+1);
                                    willDo = rscObj;
                                    with (object_emmet){
                                        if (willDo == other.willDo &amp;&amp; id != other.id){
                                            other.willDo = noone;
                                        }
                                    }
                                    if (willDo == noone || rscObj.pickedUp || instance_exists(rscObj.partOfBuilding)){
                                        if (debugIAI) debugger.text+="#BUILD : RSC part of building ("+string(rscObj.partOfBuilding)+") or picked up ("+string(rscObj.pickedUp)+"), not touching";
                                        continue;
                                    }
                                    else{  
                                        willType = WILL_PICK
                                        if (debugIAI) debugger.text+="#BUILD : Will pick";
                                        h = ds_list_size(priorities); ///// LOOP BREAKER
                                        break;
                                    } 
                                }
                            }
                            
                            else{
                                workedIt = false; //NOT WORKING ON THIS YARD...
                                gonnaSetI = i; //ONLY REASON TO CONTINUE THE LOOP...WITHOUT THIS, LOOP BREAKS
                            }
                            idle = false;
                            i = gonnaSetI;
                        }
                    }
                    if (workedIt){
                        break;
                    }
                }
                if (debugIAI) debugger.timers[? "BUILD"] = get_timer()-debugger.timers[? "BUILD"];
            }
            else if (currentPrio == PRIORITY_GATHER){
            //////////////////
            ///RESSOURCE GATHERING AND DEPOSIT
            //////////////////
                if (debugIAI) debugger.timers[? "GATHER"] = get_timer();
               
                if (instance_exists(object_pickable) &amp;&amp; instance_exists(object_building_stocker)){
                    var canDeposit = false;
                    var unloadZone = object_building_stocker;
                    
                    var buildingObject = instance_nearest(x, y, object_building_stocker);
                    
                    for (var i = 0; i &lt; instance_number(object_building_stocker); i++){
                        var thisToolStore = instance_nth_nearest(x, y, object_building_stocker, i+1);
                        if (canGoToBuilding(thisToolStore)){
                            canDeposit = true;
                            buildingObject = thisToolStore;
                            break;
                        }
                    }
                    
                    if (debugIAI) debugger.text+="#GATHER : Picking a buildingObject, "+object_get_name(buildingObject.object_index);
                    
                    
                    if (canDeposit &amp;&amp; hasBuilding(buildingObject)){
                    
                        //STOCKING
                        
                        /// About to stock
                        if (instance_exists(holding) &amp;&amp; 
                            isStockable(holding.object_index) &amp;&amp;
                            point_distance(x, y, buildingObject.x+G_CELLSIZE/2, buildingObject.y+G_CELLSIZE/2) &lt; depositDistance
                            ){
                            if (debugIAI) debugger.text+="#GATHER : About to stock";
                            var rsc = getRessourceFromObject(holding.object_index);
                            
                            addStock(rsc, 1);
                            deadEmitter = instance_create(sysToDisplayX(buildingObject.x+G_CELLSIZE/2, buildingObject.y+G_CELLSIZE/2), 
                                                            sysToDisplayY(buildingObject.x+G_CELLSIZE/2, buildingObject.y+G_CELLSIZE/2), 
                                                                object_teleporter_fx);
                            deadEmitter.width = G_CELLSIZE*2;
                            deadEmitter.particleColor = c_aqua;
                            deadEmitter.particleAlphaDropSpeed = 13;
                            deadEmitter.yCorrection = 8;
                            deadEmitter.lifeSpan = 1;
                            playSfx(sound_sfx_recall, false, buildingObject);
                            
                            with (holding){
                                instance_destroy();
                            }
                            emmetDropObject(id);
                            break;
                        }
                        /// Going to the stocker
                        else if (instance_exists(holding) &amp;&amp; isStockable(holding.object_index)){
                            if (debugIAI) debugger.text+="#GATHER : Going to stocker";
                            if (old[1] == y || old[0] == x){
                                goToBuilding(buildingObject, realSpeed);
                            }
                            h = ds_list_size(priorities); ///// LOOP BREAKER
                            break;
                        }
                        /// Willpick is occupied or part of building
                        else if (willType == WILL_PICK &amp;&amp; instance_exists(willDo) &amp;&amp; (willDo.partOfBuilding != noone || willDo.pickedUp)){
                            if (debugIAI) debugger.text+="#GATHER : Clearing willDo";
                            willDo = noone;
                            break;
                        }
                        /// Finding a ressource to pick and gather
                        else if (!instance_exists(holding)){
                            if (debugIAI) debugger.text+="#GATHER : Looking for something to pick";
                            var ressourcesArr = getRessources();
                            for (var i = 0; i &lt; array_length_1d(ressourcesArr); i++){
                                var rscObject = getRessource(ressourcesArr[i], "object");
                                if (!isStockable(rscObject)){
                                    continue;
                                }
                                if (instance_exists(rscObject)){
                                    for (var j = 0; j &lt; instance_number(rscObject) ; j ++){
                                        willDo = instance_nth_nearest(x,y, rscObject, j+1);
                                        var anypath = path_add();
                                        with (object_emmet){
                                            if (willDo == other.willDo &amp;&amp; id != other.id){
                                                other.willDo = noone;
                                            }
                                        }
                                        if (instance_exists(willDo) &amp;&amp; !willDo.pickedUp &amp;&amp; willDo.partOfBuilding == noone &amp;&amp; mp_grid_path(global.grid, anypath, x, y, willDo.x, willDo.y, true)){
                                            h = ds_list_size(priorities); ///// LOOP BREAKER
                                            i = array_length_1d(ressourcesArr); ///// RESSOURCE LOOP BREAKER
                                            if (debugIAI) debugger.text+="#GATHER : Will pick "+object_get_name(willDo.object_index);
                                            willType = WILL_PICK;
                                            break;
                                        }
                                    }                            
                                }
                            }
                        }
                    }
                }
                if (debugIAI) debugger.timers[? "GATHER"] = get_timer()-debugger.timers[? "GATHER"];
            }
            else if (currentPrio == PRIORITY_CLEAR_GRAVEL &amp;&amp; hasEquipment(EQUIPMENT_SHOVEL) &amp;&amp; !instance_exists(holding)){
            //////////////////
            /// RUBBLE CLEARING
            //////////////////
                if (debugIAI) debugger.timers[? "CLEAR"] = get_timer();
                
                var myObjectives = getGravelToClearList();
                var size = ds_list_size(myObjectives);
                if (size &gt; 0){
                    var queue = ds_list_create();
                    var objectivesMap = ds_map_logcreate();
                    for (var j = 0; j &lt; size ; j ++){
                        var thisObjective = ds_list_find_value(myObjectives, j);
                        if (getGravel(thisObjective) != noone){
                            var distance = point_distance(thisObjective[0]*G_CELLSIZE, thisObjective[1]*G_CELLSIZE, x, y);
                            ds_list_add(queue, distance);
                            ds_map_add(objectivesMap, distance, thisObjective);
                        }
                    }
                    
                    ds_list_sort(queue, true);
                    var queueSize = ds_list_size(queue);
                    
                    for (var j = 0; j &lt; queueSize; j++){
                        var thisObjectiveFromQueue = ds_list_find_value(queue, j);
                        var thisObjectiveFromMap = ds_map_find_value(objectivesMap, thisObjectiveFromQueue);
                        if (!is_undefined(thisObjectiveFromMap)){
                            willClear = thisObjectiveFromMap;
                            anypath = path_add();
                            with (object_emmet){
                                if ((willClear[0] == other.willClear[0] &amp;&amp; willClear[1] == other.willClear[1])  &amp;&amp; id != other.id){
                                    other.willClear = array(0,0);
                                }
                            }
                            if (isMarkedToClear(willClear) &amp;&amp; mp_grid_path(global.grid, anypath, x, y, willClear[0]*G_CELLSIZE+G_CELLSIZE/2, willClear[1]*G_CELLSIZE+G_CELLSIZE/2, true)){
                                h = ds_list_size(priorities); ///// LOOP BREAKER
                                willType = WILL_CLEAR;
                                break;
                            }
                            else{
                                willClear = array(0,0);
                            }
                        }
                    }
                    ds_list_destroy(queue);
                    ds_map_logdestroy(objectivesMap);
                }
                if (debugIAI) debugger.timers[? "CLEAR"] = get_timer()-debugger.timers[? "CLEAR"];
            }
            else if (currentPrio == PRIORITY_DRILL &amp;&amp; hasEquipment(EQUIPMENT_DRILL) &amp;&amp; !instance_exists(holding)){
            //////////////////
            /// WALL DRILLING
            //////////////////
                if (debugIAI) debugger.timers[? "DRILL"] = get_timer();
                
                var myObjectives = getWallToDrillList();
                var size = ds_list_size(myObjectives);
                if (size &gt; 0){
                                    
                    var queue = ds_list_create();
                    var objectivesMap = ds_map_logcreate();
                    for (var j = 0; j &lt; size ; j ++){
                        var thisObjective = ds_list_find_value(myObjectives, j);
                        if (getWallMap(thisObjective) != false){
                            var distance = point_distance(thisObjective[0]*G_CELLSIZE, thisObjective[1]*G_CELLSIZE, x, y);
                            ds_list_add(queue, distance);
                            ds_map_add(objectivesMap, distance, thisObjective);
                        }
                    }
                    
                    ds_list_sort(queue, true);
                    var queueSize = ds_list_size(queue);
                    
                    for (var j = 0; j &lt; queueSize; j++){
                        var thisObjectiveFromQueue = ds_list_find_value(queue, j);
                        var thisObjectiveFromMap = ds_map_find_value(objectivesMap, thisObjectiveFromQueue);
                        if (!is_undefined(thisObjectiveFromMap)){
                        
                            willDrill = thisObjectiveFromMap;
                            anypath = path_add();
                            
                            with (object_emmet){
                                if ((willDrill[0] == other.willDrill[0] &amp;&amp; willDrill[1] == other.willDrill[1]) &amp;&amp; id != other.id){
                                    other.willDrill = array(noone, noone);
                                }
                            }
                            
                            if (isMarkedToDrill(willDrill)){
                            
                                var original = array(willDrill[0]*G_CELLSIZE + G_CELLSIZE/2, willDrill[1]*G_CELLSIZE + G_CELLSIZE/2);
                                var objectives = array(
                                                    array(original[0], original[1] - G_CELLSIZE*0.7),
                                                     array(original[0] - G_CELLSIZE*0.7, original[1]),
                                                     array(original[0], original[1] + G_CELLSIZE*0.7),
                                                     array(original[0] + G_CELLSIZE*0.7, original[1])
                                                    );
                                var found = false;
                                for (var k = 0; k &lt; array_length_1d(objectives); k++){
                                    var objective = objectives[k];
                                    if (mp_grid_path(global.grid, anypath, x, y, objective[0], objective[1], true)){
                                        h = ds_list_size(priorities); ///// LOOP BREAKER
                                        willType = WILL_DRILL;
                                        found = true;
                                        break;
                                    }
                                }
                                if (found){
                                    break;
                                }
                                else{
                                    willDrill = array(noone, noone);
                                }
                            }
                            else{
                                willDrill = array(noone, noone);
                            }
                        }
                    }
                    ds_list_destroy(queue);
                    ds_map_logdestroy(objectivesMap);
                }
                if (debugIAI) debugger.timers[? "DRILL"] = get_timer()-debugger.timers[? "DRILL"];
            }
            
            else if (currentPrio == PRIORITY_REFINE){
            //////////////////
            ///RESSOURCE REFINING AND DEPOSIT AT THE REFINTERY
            //////////////////
               
                if (debugIAI) debugger.timers[? "REFINE"] = get_timer();
                if (instance_exists(object_pickable) &amp;&amp; 
                    hasBuilding(object_building_refinery)){
                    
                    
                    var canDeposit = false;
                    
                    var buildingObject = instance_nearest(x, y, object_building_refinery);
                    
                    for (var i = 0; i &lt; instance_number(object_building_refinery); i++){
                        var thisToolStore = instance_nth_nearest(x, y, object_building_refinery, i+1);
                        if (thisToolStore.initialized &amp;&amp; canGoToBuilding(thisToolStore)){
                            canDeposit = true;
                            buildingObject = thisToolStore;
                            break;
                        }
                    }
                    if (canDeposit &amp;&amp; instance_exists(buildingObject)){
                    
                    
                        //GIVING TO REFINERY
                        
                        /// About to refine
                        if (instance_exists(holding) &amp;&amp; 
                            isRough(getRessourceFromObject(holding.object_index)) &amp;&amp;
                            point_distance(x, y, buildingObject.x+G_CELLSIZE/2, buildingObject.y+G_CELLSIZE/2) &lt; depositDistance
                            ){
                     
                            var rsc = getRessourceFromObject(holding.object_index);
                            
                            addToRefine(buildingObject, rsc);
                            
                            with (holding){
                                instance_destroy();
                            }
                            emmetDropObject(id);
                            
                            if (debugIAI) debugger.text+="#REFINE : About to refine";
                            
                            break;
                        }
                        /// Going to the refinery
                        else if (instance_exists(holding) &amp;&amp; isRough(getRessourceFromObject(holding.object_index))){
                            
                            if (old[1] == y || old[0] == x){
                                goToBuilding(buildingObject, realSpeed);
                            }
                            h = ds_list_size(priorities); ///// LOOP BREAKER
                            
                            if (debugIAI) debugger.text+="#REFINE : GOING TO THE REFINERY";
                            
                            break;
                        }
                        /// Willpick is occupied or part of building
                        else if (willType == WILL_PICK &amp;&amp; instance_exists(willDo) &amp;&amp; (willDo.partOfBuilding != noone || willDo.pickedUp)){
                       
                            willDo = noone;
                            
                            if (debugIAI) debugger.text+="#REFINE : CANNOT WILLPICK";
                            
                            break;
                        }
                        /// Finding a ressource to pick and gather
                        else{
                            
                            if (debugIAI) debugger.text+="#REFINE : FINDING A RESSOURCE TO PICK";
                            
                            var ressourcesArr = getRoughMaterials();
                            for (var i = 0; i &lt; array_length_1d(ressourcesArr); i++){
                                var rscObject = getRessource(ressourcesArr[i], "object");
                                
                                if (instance_exists(rscObject)){
                                
                                    for (var j = 0; j &lt; instance_number(rscObject) ; j ++){
                                        willDo = instance_nth_nearest(x,y, rscObject, j+1);
                                        var anypath = path_add();
                                        with (object_emmet){
                                            if (willDo == other.willDo &amp;&amp; id != other.id){
                                                other.willDo = noone;
                                            }
                                        }
                                        if (instance_exists(willDo) &amp;&amp; !willDo.pickedUp &amp;&amp; willDo.partOfBuilding == noone &amp;&amp; canGo(array(willDo.x, willDo.y), array(x, y))){
                                            h = ds_list_size(priorities); ///// LOOP BREAKER
                                            i = array_length_1d(ressourcesArr); ///// RESSOURCE LOOP BREAKER
                                            willType = WILL_PICK;
                                            break;
                                        }
                                    }                            
                                }
                            }
                        }
                    }
                }
                else if (!hasBuilding(object_building_refinery) &amp;&amp; instance_exists(holding) &amp;&amp; isRough(getRessourceFromObject(holding.object_index))){
                    emmetDropObject(id);
                }
                if (debugIAI) debugger.timers[? "REFINE"] = get_timer()-debugger.timers[? "REFINE"];
            }
            else if (currentPrio == PRIORITY_DYNAMITE){
                
                if (debugIAI) debugger.timers[? "DYNAMITE"] = get_timer();
                if (instance_exists(holding) &amp;&amp; holding.object_index == object_pickable_dynamite){
                     if (debugIAI) debugger.text+="#DYNAMITE :  I am holding a dynamite and I'm idle";
                /// "I'm holding a dynamite and i don't know what to do"
                
                    if (hasTraining(TRAINING_DYNAMITE)){
                        if (debugIAI) debugger.text+="#DYNAMITE :  WILL_DYNAMITE";
                        willType = WILL_DYNAMITE;
                        h = ds_list_size(priorities); 
                        break;
                    }
                    else{
                        emmetDropObject(id);
                    }
                }
                else if (!instance_exists(holding) &amp;&amp; instance_exists(object_pickable_dynamite) &amp;&amp; ds_list_size(object_drillman.dynamiteObjectives) &gt; 0){
                     if (debugIAI) debugger.text+="#DYNAMITE :  Not holding anything and a dynamite exists";
                
                /// "There is dynamite laying on the ground and it's not mine (yet)"
                
                    if (hasTraining(TRAINING_DYNAMITE)){
                         if (debugIAI) debugger.text+="#DYNAMITE :  behaviorPicking it";
                        emmetBehaviorPick(object_pickable_dynamite);
                        h = ds_list_size(priorities); 
                        break;
                    }
                }
                
                if (debugIAI) debugger.timers[? "DYNAMITE"] = get_timer()-debugger.timers[? "DYNAMITE"];
            }
        }
        
        //ai part not to stay on yards or near dynamites...defaulting
        var dyna = instance_nearest(x, y, object_triggered_dynamite);
        
        if ((onChunk(array(x/G_CELLSIZE,y/G_CELLSIZE), object_building_yard) || 
            onChunk(array(x/G_CELLSIZE,y/G_CELLSIZE), object_building_parent) ||
                (instance_exists(dyna) &amp;&amp; point_distance(dyna.x, dyna.y, x, y) &lt; G_CELLSIZE*2)) 
            &amp;&amp; x == old[0] &amp;&amp; y == old[1]){
            //debugMe("AVOIDING", "DYNAMITE");
            var isoIndex = getIsoIndex(array(x,y));
            var possibilities = getSurroundingsIndex(array(isoIndex[0]-1, isoIndex[1]-1), 3);
            var objective = array(noone);
            for (var i = 0; i &lt; array_length_1d(possibilities); i++){
                var thisPossibility = possibilities[i];
                if (isVisible(thisPossibility) &amp;&amp; !onChunk(thisPossibility, object_solid)){
                  //  spawnChunkPainter(objective, c_lime, 1);
                    objective = thisPossibility;
                }
            }
            if (objective[0] != noone){
               // spawnChunkPainter(objective, c_aqua, 1);
                var realObjective = array(objective[0]*G_CELLSIZE + G_CELLSIZE/2, objective[1]*G_CELLSIZE + G_CELLSIZE/2);
                if (instance_exists(dyna)){
                    pathTo(array(realObjective[0], realObjective[1]), realSpeed);
                }
                else{
                    pathTo(array(realObjective[0], realObjective[1]), realSpeed);
                }
            }
        }
    }
    else{
        if (debugIAI) debugger.text = "Idle or not chosen to think."
    }
}
else{
    path_speed = 0;
}
                                
//END
debugIAI = false;
old = array(x, y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!object_debug.orthographic){
    drawPos = sysToDisplay(array(x,y));
    xDraw = drawPos[0];
    yDraw = drawPos[1];
}
else{
    xDraw = x;
    yDraw = y;
}
xScale = 1;

/// Training fancy stuff
/*
for (var i = 0; i &lt; ds_list_size(trainings); i++){
    var training = trainings[| i];
    switch (training){
        case TRAINING_GEOLOG:
        
            break;
    }
}
*/

/// Emmet sprite drawing

switch (round(facing/90)){
    default:
        spriteToDraw = sprite_emmet_idle_back;
        break;
    case 2:
        xScale = -1;
    case 4:
    case 0:
        spriteToDraw = sprite_emmet_idle_side;
        break;
    }

var actSpeed=  0;

if (isClearing){
    actSpeed = moveSpeed;
    switch (round(facing/90)){
        default:
            spriteToDraw = sprite_emmet_clearing_back;
            break;
        case 2:
            xScale = -1;
        case 4:
        case 0:
            spriteToDraw = sprite_emmet_clearing_side;
            break;
    }
}
else if (isDrilling){
    if (getWallMap(willDrill) != false){
        facing = point_direction(xDraw, yDraw, sysToDisplayX(willDrill[0]*G_CELLSIZE, willDrill[1]*G_CELLSIZE), sysToDisplayY(willDrill[0]*G_CELLSIZE, willDrill[1]*G_CELLSIZE));
    }
    actSpeed = moveSpeed;
    switch (round(facing/90)){
        default:
            spriteToDraw = sprite_emmet_drilling_back;
            break;
        case 1:
            spriteToDraw = sprite_emmet_drilling_face;
        case 2:
            xScale = -1;
        case 4:
        case 0:
            spriteToDraw = sprite_emmet_drilling_side;
            break;
    }
}
else if (old[0] != x || old[1] != y){
    actSpeed = abs(old[0]-x) + abs(old[1]-y);
    facing = point_direction(oldDraw[0], oldDraw[1], xDraw, yDraw);
    switch (round(facing/90)){
        default:
            spriteToDraw = sprite_emmet_walking_back;
            break;
        case 2:
            xScale = -1;
        case 4:
        case 0:
            spriteToDraw = sprite_emmet_walking_side;
            break;
    }
    /// Draw path
    /*
    draw_set_color(c_lime);
    draw_path(path, xDraw, yDraw, false);
    */
}

if (!destroy){
    animIndex = (animIndex + (1/60)*animSpeed*(actSpeed/moveSpeed))%sprite_get_number(spriteToDraw);
    draw_sprite_ext(spriteToDraw, animIndex, xDraw, yDraw-timerOfArrival*30, xScale, 1, 0, color, alpha-timerOfArrival);
    
    if (instance_exists(holding)){
        draw_sprite(holding.sprite_index, 0, xDraw+1, yDraw-3);
    }
}
else{
    spriteToDraw = sprite_emmet_destroyed;
    animIndex = (animIndex + (1/60)*animSpeed);
    if (sprite_get_number(spriteToDraw) &lt;= animIndex){
        var tomb = instance_create(x, y, object_tombstone);
        tomb.name = name;
        instance_destroy();
        exit;
    }
    draw_sprite_ext(spriteToDraw, animIndex, xDraw, yDraw, xScale, 1, 0, color, alpha-timerOfArrival);
}


//END
oldDraw = array(xDraw, yDraw);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
