<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_wall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>object_solid</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//INIT
depth = LAYER_HIGH-10;
var pos = snapToGrid(array(x+G_CELLSIZE/2,y+G_CELLSIZE/2));
x = pos[0];
y = pos[1];


fakeX = x+G_CELLSIZE/2;
fakeY = y+G_CELLSIZE/2;

ownIsoIndex = array(round(x/G_CELLSIZE), round(y/G_CELLSIZE));
//instance_create(x,y, object_vision_explorer);

//ANIMATION
arriving = 2;
firstStep = true;
topDisplayer = instance_create(x,y, object_topbuilding_displayer);
sprite = getBuilding(object_index, "sprite");
topDisplayer.spriteToDraw = sprite;
topDisplayer.size = getBuilding(object_index, "size");
topDisplayer.parent = id;
hovered = false;
playedWarning = false;

//DED
deadGiveoutBonus = 0;
destroy = false;    /// Will destroy the building instead of teleporting it

//HP
drawHp = true;
maxHp = 100;
actHp = maxHp;
dead = false;
hasFoldedPathways = false;
gaveOutRessources = false;
lifeHeight = G_CELLSIZE+4;
lifeWidth = sprite_get_width(sprite)/2;

//POWER
powered = false;
powerSwitch = true; //if powerswitch is TRUE, the building is ON and needs POWER
oldPowerSwitch = powerSwitch;

//PATHWAY
surroundingPathwaysPos = getSurroundingsIndex(ownIsoIndex, getBuilding(object_index, "size"));

surroundingPathways = array(0);
for (var i = 0; i &lt; array_length_1d(surroundingPathwaysPos); i++){
    surroundingPathways[i] = noone;
}

//TPFX
tpFX(pos, G_CELLSIZE);
initialized = false;
hasPlayedRecall = false;
hasPlayedTeleportIn = false;

/// GAUGE - Used for some buildings
gauge = 1;
drawGauge = false;
gaugeHeight = G_CELLSIZE+2;
gaugeWidth = sprite_get_width(sprite)/2;
specialNeed = false;
specialNeedFulfilled = false;
specialNeedHumor = HUMOR_WATER;
specialNeedColor = c_aqua;
specialNeedTimer = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Scale correction//should be in the create...but i'm lazy
var size = getBuilding(object_index, "size");
image_xscale = size;
image_yscale = size;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EXIT IF PAUSED
if (object_game.paused || !object_game.inGame){

    for (var i = 0; i &lt; array_length_1d(surroundingPathwaysPos); i++){
        with (surroundingPathways[i]){
            speed = 0;
        }
    }
    exit;
}
else if (!dead){
    for (var i = 0; i &lt; array_length_1d(surroundingPathwaysPos); i++){
        with (surroundingPathways[i]){
            if (point_distance(x, y, objectives[0]*G_CELLSIZE, objectives[1]*G_CELLSIZE) &gt; 0.2){
                move_towards_point(objectives[0]*G_CELLSIZE, objectives[1]*G_CELLSIZE, 0.3);
            }
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DEAD (exit)
if (actHp &lt;= 0 || dead){
    dead = true;
    if (isSelectedBuilding(id)){
        clearSelection();
    }
    if (initialized){
        initialized = false;
        refreshNRG();
        adoptBuildingDeath(object_index);
        playSfx(sound_sfx_building_refolding, false, id);
        if (actHp &lt;= 0){
            destroy = true;
        }
    }
    actHp = 0;
    
    if (hasFoldedPathways){
        /// Destroying the pathway below me
        
        if (!hasPlayedRecall){
            hasPlayedRecall = true;
            playSfx(sound_sfx_building_recall, false, id);
        }
        
        var region = growToRoom(ownIsoIndex, getBuilding(object_index, "size"));
        for (var i = region[0]; i &lt; region[2]; i++){
            for (var j = region[1]; j &lt; region[3]; j++){
                var index = array(i, j);
                var col = onChunk(index, object_ground_pathway);
                if (instance_exists(col)){
                    with (col){
                        instance_destroy();
                    }
                }
            }
        }
        if (destroy){
            instance_create(x,y, object_explosion_fx);
            with (topDisplayer){
                instance_destroy();
            }
            instance_destroy();
        }
        else{
            if (arriving &lt;= 0.3){
                arriving += 0.01;
            }
            arriving *= 1.02;
            if (arriving &gt;= 2){
                addHardStock(object_index);
                with (topDisplayer){
                    instance_destroy();
                }
                instance_destroy();
            }
        }
    }
    else{
        hasFoldedPathways = true;
        for (var i = 0; i &lt; array_length_1d(surroundingPathways); i++){
            with (surroundingPathways[i]){
                if (speed == 0){
                    move_towards_point(other.x, other.y, 0.3);
                }
                if (point_distance(x, y, other.x, other.y) &lt; 0.2){
                    other.deadGiveoutBonus+= 2;
                    instance_destroy();
                }
            }
            if (instance_exists(surroundingPathways[i])){
                hasFoldedPathways = false;
            }
        }
    }
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if (arriving &gt; 0.03){
    arriving /= 1.02;
    if (!hasPlayedTeleportIn){
        playSfx(sound_sfx_building_teleport_in, false, id);
        hasPlayedTeleportIn = true;
    }
    exit;
} 
else{
    arriving = 0;
    depth = -(x + y);
}

if (firstStep){
    firstStep = false;
    playSfx(sound_sfx_building_metalbang, false, id);
    
    var deployedAtLeastOne = false;
    for (var i = 0; i &lt; array_length_1d(surroundingPathwaysPos); i++){
        var thisPos = surroundingPathwaysPos[i];
        if (canBuildOn(object_ground_pathway, thisPos)){
            surroundingPathways[i] = instance_create(x, y, object_ground_pathway);
            surroundingPathways[i].checkNRG = false;
            deployedAtLeastOne = true;
            if (instance_exists(surroundingPathways[i])){
                surroundingPathways[i].objectives = thisPos;
            }
            with (surroundingPathways[i]){
                move_towards_point(objectives[0]*G_CELLSIZE, objectives[1]*G_CELLSIZE, 0.3);
            }
        }
    }
    if (deployedAtLeastOne){
        playSfx(sound_sfx_building_unfolding, false, id);
    }
    
    var pwZone = growToRoom(ownIsoIndex, getBuilding(object_index, "size"));
    for (var i = pwZone[0]; i &lt; pwZone[2]; i++){
        for (var j = pwZone[1]; j &lt; pwZone[3]; j++){
            var pw = instance_create(i*G_CELLSIZE, j*G_CELLSIZE, object_ground_pathway);
            pw.depth = depth+G_CELLSIZE;
            pw.checkNRG = false;
        }
    }
    
}
else if (!initialized){
    initialized = true;
    for (var i = 0; i &lt; array_length_1d(surroundingPathways); i++){
        with (surroundingPathways[i]){
            if (point_distance(x, y, objectives[0]*G_CELLSIZE, objectives[1]*G_CELLSIZE) &lt; 0.2){
                speed = 0;
                var pos = snapToGrid(array(x+G_CELLSIZE/2,y+G_CELLSIZE/2));
                x = pos[0];
                y = pos[1];
            }
            else{
                other.initialized = false;
            }
        }
    }
    if (initialized){
        refreshPathfinder();
        refreshNRG();
    }
}
else{    
    if (powerSwitch != oldPowerSwitch){
        refreshNRG();
    }
    
    adoptBuildingBehavior(object_index);
    
    oldPowerSwitch = powerSwitch;
} 
topDisplayer.gauge = gauge;
topDisplayer.drawGauge = drawGauge;
topDisplayer.gaugeWidth = gaugeWidth;
topDisplayer.gaugeHeight = gaugeHeight;
topDisplayer.x = x;
topDisplayer.y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var drawPos = sysToDisplay(array(x,y));
var color = c_white;
if (isSelectedBuilding(id)){
    color = selectionColor();
}
else if (hovered){
    color = hoverColor();
}

draw_set_color(c_aqua);

topDisplayer.color = color;

if (object_debug.orthographic){
    draw_rectangle(x, y, x+G_CELLSIZE, y+G_CELLSIZE, false);
}
else{
    if (initialized &amp;&amp; (!powerNeeded(id) || powered) &amp;&amp; powerSwitch &amp;&amp; (!specialNeed || specialNeedFulfilled)){
        topDisplayer.imageIndex = 0;
        topDisplayer.alpha = 1;
        draw_sprite_ext(sprite, 0, drawPos[0], drawPos[1], 1, 1, 0, color, 1);
    }
    else{
        topDisplayer.imageIndex = 1;
        topDisplayer.alpha = (2 - arriving)/2;
        topDisplayer.drawPos = array(drawPos[0], drawPos[1] - arriving*50);
        draw_sprite_ext(sprite, 1, drawPos[0], drawPos[1] - arriving*50, 1, 1, 0, color, (2 - arriving)/2);
        
        if (!powerSwitch){
            drawHumor(HUMOR_DISABLED, id, c_red, 0.75, false);
        }
        else if (initialized &amp; !powered){
            drawHumor(HUMOR_ENERGY, id, c_yellow, abs(sin(get_timer()/500000)), false);
            if (round(abs(sin(get_timer()/500000))) == 1 &amp;&amp; !audio_is_playing(sound_sfx_building_energy_alarm) &amp;&amp; !playedWarning){
                playSfx(sound_sfx_building_energy_alarm, false, id, true, 0.2);
                playedWarning = true;
            }
            else{
                playedWarning = false;
            }
        }
        else if (specialNeed &amp;&amp; !specialNeedFulfilled){
            drawHumor(specialNeedHumor, id, specialNeedColor, abs(sin(get_timer()/500000)), false);
            if (round(abs(sin(get_timer()/500000))) == 1 &amp;&amp; !audio_is_playing(sound_sfx_building_energy_alarm) &amp;&amp; !playedWarning){
                playSfx(sound_sfx_building_energy_alarm, false, id, true, 0.2);
                playedWarning = true;
            }
            else{
                playedWarning = false;
            }
        }
    }
    
    // HP   
    if (actHp &lt; maxHp &amp;&amp; drawHp &amp;&amp; !dead){
        drawBlock(array(drawPos[0]-lifeWidth/2, drawPos[1]-lifeHeight, drawPos[0]+lifeWidth/2,drawPos[1]-lifeHeight), array(c_red, COLOR_BACKGROUND(), COLOR_SHADOW()));      
        drawBlock(array(drawPos[0]-lifeWidth/2, drawPos[1]-lifeHeight, drawPos[0]+(lifeWidth)*(actHp/maxHp)-(lifeWidth/2), drawPos[1]-lifeHeight), array(c_lime, COLOR_BACKGROUND(), COLOR_SHADOW()));
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
