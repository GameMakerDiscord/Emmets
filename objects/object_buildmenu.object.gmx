<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_ui_lefttab_build</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>unique();
depth = HUD_DEPTH;

var vx = view_xview;
var vy = view_yview;
var w = view_wview;
var h = view_hview;

buildings = array(noone);
countToDisplay = 7;
spacing = 7;
hMargin = 2;
iconSize = 32;
bottomScreenMargin = 12;
hotkeySize = 10;

/// counters
unfolded = false;
currentPosition = 0;
buildingBuildable = array(noone);
buildingStock = array(noone);

// init
var gb = getBuildings();
/*
for (var i = 0; i &lt; array_length_1d(gb); i++){
    var thisBuild = gb[i];
    if (isBuildable(thisBuild)){
        if (buildings[0]  == noone){
            buildings[0] = thisBuild;
        }
        else{
            buildings[array_length_1d(buildings)] = thisBuild;
        }
    }
}
*/
colors = array(COLOR_FOREGROUND(), COLOR_BACKGROUND(), COLOR_SHADOW());
hoveredColors = array(COLOR_BACKGROUND(), COLOR_FOREGROUND(), COLOR_SHADOW());
buildings = gb;
hoveredItem = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///EXIT IF MAIN MENU
if (notAGameRoom(room)){
    visible = false;
    exit;
}
else{
    visible = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF WINDOWS ONTOP
willExit = anotherWindowOnTop();
if (willExit){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vx = view_xview;
var vy = view_yview;
var w = view_wview;
var h = view_hview;

    var nbItems = min(currentPosition+countToDisplay, array_length_1d(buildings));  
    var width = spacing + nbItems*spacing + nbItems*iconSize + spacing;
    x = vx + UI_LEFT_BAND -1;
    y = vy + h - bottomScreenMargin - sprite_get_height(sprite_index);
    
if (!unfolded &amp;&amp; !global.i[I_BUILDINGS]){
    if (global.i[I_SELECT_HELD]){
        if (mouseIn(array(x, y, x+sprite_get_width(sprite_index), y+sprite_get_height(sprite_index)))){
            unfolded = true;
            playSfx(sound_sfx_select);
        }
    }
}
else if (unfolded || global.i[I_BUILDINGS]){
    for (var i = 0; i &lt; array_length_1d(buildings); i++){
        var thisBuild = buildings[i];
        var can = canProduce(thisBuild);
        var stock = getHardStock(thisBuild);
    
        buildingBuildable[i] = can;
        buildingStock[i] = stock;      
    }  
    var nbItems = min(currentPosition+countToDisplay, array_length_1d(buildings));  
    var width = spacing + nbItems*spacing + nbItems*sprite_get_width(sprite_building_dummy) + spacing;
    
    if (global.i[I_SELECT]){
        var sp = array(
            x + width,
            y + sprite_get_height(sprite_building_dummy) - sprite_get_height(sprite_index) - sprite_get_height(sprite_index)/2,
            x + width + sprite_get_width(sprite_index),
            y + sprite_get_height(sprite_building_dummy) - sprite_get_height(sprite_index)/2
        );
        
        if (point_in_rectangle(global.i[I_X], global.i[I_Y], sp[0], sp[1], sp[2], sp[3])){
            unfolded = false;
            playSfx(sound_sfx_select);
        }
    }
    
    var hoveredSomething = false;
    for (var i = currentPosition; i &lt; nbItems; i++){
        var thisBuild = buildings[i];
        var sprite = sprite_building_dummy;
        var spritePos = array(
            x + spacing + (spacing+sprite_get_width(sprite))*i,
            y + sprite_get_height(sprite_index)-hMargin-sprite_get_height(sprite) -1
        );
        
        if (mouseIn(array(spritePos[0], spritePos[1], spritePos[0]+sprite_get_width(sprite), spritePos[1]+sprite_get_height(sprite)))){
            hoveredItem = i;
            hoveredSomething = true;
            
            drawTip(
                translate(BUILDING, object_get_name(thisBuild))
                +"#"+translate("BUILDING_TIP", object_get_name(thisBuild))
                +formattedNeeds(thisBuild)+"##"+translate("GENERAL_TIP", "BUILD")
            );
            
            if (global.i[I_ACTION] &amp;&amp; buildingBuildable[i]){
                produceBuilding(thisBuild);
            }
            else if (global.i[I_SELECT] &amp;&amp; getHardStock(thisBuild) &gt; 0){
                cursorPlaceBuilding(thisBuild);
                playSfx(sound_sfx_select);  
            }
        }
        
        /// HOTKEYS
        if (global.i[I_BUILDINGS] &amp;&amp; global.i[getItemHotkey(i)]){
            if (getHardStock(thisBuild) &gt; 0){
                cursorPlaceBuilding(thisBuild);
            }
            else if (buildingBuildable[i]){
                produceBuilding(thisBuild);
            }
        }
    }    
    if (!hoveredSomething){
        hoveredItem = noone;
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
colors = array(COLOR_FOREGROUND(), COLOR_BACKGROUND(), COLOR_SHADOW());
hoveredColors = array(COLOR_BACKGROUND(), COLOR_FOREGROUND(), COLOR_SHADOW());

if (!unfolded &amp;&amp; !global.i[I_BUILDINGS]){
    drawBlock(array(x, y, x+sprite_get_width(sprite_index), y+sprite_get_height(sprite_index)), colors);
    draw_sprite_ext(sprite_index, unfolded, x, y, 1, 1, 0, object_station.company[?"color"], 1);
}
else{
    if (buildingBuildable[0] == noone){
        exit;
    }
    var nbItems = min(currentPosition+countToDisplay, array_length_1d(buildings));  
    var width = spacing + nbItems*spacing + nbItems*iconSize + spacing;
    var height = hMargin + iconSize + hMargin;

    /// Drawing band
    
    draw_set_color(COLOR_SHADOW());
    draw_rectangle(x+1, 
                    y+sprite_get_height(sprite_index)-height+1, 
                    x+width+1 , 
                    y+sprite_get_height(sprite_index)+1 , 
                    false);
    
    draw_set_color(COLOR_BACKGROUND());
    draw_rectangle(x, 
                    y+sprite_get_height(sprite_index)-height, 
                    x+width, 
                    y+sprite_get_height(sprite_index), 
                    false);
    
    draw_set_color(COLOR_FOREGROUND());
    draw_rectangle(x ,
                    y+sprite_get_height(sprite_index)-height, 
                    x+width, 
                    y+sprite_get_height(sprite_index) , 
                    true);
    
    /// Drawing the building sprites first
    for (var i = currentPosition; i &lt; nbItems; i++){
        var thisBuild = buildings[i];
        
        var sprite = getBuilding(thisBuild, "sprite");
        var spritePos = array(
            x + spacing + (spacing+iconSize)*i  ,
            y+sprite_get_height(sprite_index)-hMargin-iconSize
        );
        
        var myColors = colors;
        if (!buildingBuildable[i] &amp;&amp; getHardStock(thisBuild) &lt;= 0){
            myColors = array(COLOR_BACKGROUND(), COLOR_BACKGROUND(), COLOR_SHADOW());
        }
        else if (hoveredItem == i){
            myColors = hoveredColors;
        }
        
        drawBlock(array(spritePos[0]-2, spritePos[1]-2, spritePos[0]+2+iconSize, spritePos[1]+2+iconSize), myColors, 1);
        
        if (isProducing(thisBuild)){
            draw_set_color(productionColor());
            draw_rectangle(spritePos[0]-1,
                            spritePos[1]+iconSize - (iconSize*productionProgression(thisBuild)),
                            spritePos[0]+iconSize+1,
                            spritePos[1]+iconSize,
                            false);
        }        
        if (!buildingBuildable[i]) shader_set(shader_grayscale);
        draw_sprite_part_ext(sprite, 0, 0,0,iconSize,iconSize, spritePos[0]+1, spritePos[1]+1, 1, 1, COLOR_SHADOW(), 1);
        draw_sprite_part(sprite, 0, 0,0,iconSize,iconSize, spritePos[0], spritePos[1]);
        shader_reset();
        
        if (!isBuildable(thisBuild) &amp;&amp; getHardStock(thisBuild) &lt;= 0){
            //draw_sprite(sprite_ui_cannotbuild, 0, spritePos[0]+iconSize/2, spritePos[1]+iconSize/2);
        }
        
        /// Hotkeys
        if (getSetting("enableHotkeys") &amp;&amp; getSetting("displayHotkeys") &amp;&amp; global.i[I_BUILDINGS]){
            var block = array(spritePos[0] + hotkeySize,
                                spritePos[1] + hotkeySize,
                                spritePos[0],
                                spritePos[1]
                            );
            var hotColors = array(DEFAULT_COLOR, merge_colour(DEFAULT_COLOR,c_black, 0.4), COLOR_SHADOW());
            drawBlock(block, hotColors, 0);
            draw_set_font(font_tiniest);
            draw_set_halign(fa_center);
            draw_set_valign(fa_middle);
            drawShadowedText(mean(block[0], block[2]), mean(block[1], block[3]),  chr(object_pad.key_map[getItemHotkey(i)]), hotColors);
        }
    }    
    
    /// then the stock amount
    for (var i = currentPosition; i &lt; nbItems; i++){
        var thisBuild = buildings[i];
    
        var sprite = getBuilding(thisBuild, "sprite");
        var textPos = array(
            x + spacing + (spacing+iconSize)*i    + iconSize,
            y + iconSize/2 +hMargin
        );
        
        draw_set_valign(fa_bottom);
        draw_set_halign(fa_right);
        draw_set_font(font_ui);
        
        if (buildingStock[i] &gt; 0){
            drawBlock(array(textPos[0]-16, textPos[1]-12, textPos[0]+2, textPos[1]+2), colors, 1);
            drawShadowedText(textPos[0], textPos[1], "x"+string(buildingStock[i]));
        }
    }
    drawBlock(array(x+width, y, x+width+sprite_get_width(sprite_index), y+sprite_get_height(sprite_index)), colors);
    draw_sprite_ext(sprite_index, unfolded, x+width, y, 1, 1, 0, object_station.company[?"color"], 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
