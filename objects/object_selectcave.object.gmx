<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_selectcave</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>unique();
depth = HUD_DEPTH;
depthUnit = 3;
scrollUnit = 128;

availableCavesList = ds_list_create();

lastName = 0;
displayLevels = 2;

unitScale = 180;

previousHeight = 100;
branchHeight = 200;
nextHeight = previousHeight + unitScale;

buttonWidth = 160;
buttonHeight = 64;

hoveredCave = noone;
hoveredBack = false;
disabledRelocate = false;
hoveredRelocate = false;
scrollLevel = 0;

panningStart = 480;
panningSpeed = 60;
currentPanning = 0;
panned = false;

rulerX = 64;
setBack = 16;

interiorPadding = 8;
cave = noone;

currentPlanet = rrandom(PLANETS-1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF NOT SELECTCAVE ROOM
if (room != station_selectcave){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF WINDOWS ONTOP
willExit = anotherWindowOnTop();
if (willExit){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vx = view_xview;
var vy = view_yview;
var w = view_wview;
var h = view_hview;
    
var left = vx+UI_LEFT_BAND+interiorPadding;
var right = vx+w-interiorPadding-UI_RIGHT_BAND;
var top = vy+UI_TOP_BAND+interiorPadding;
var height = vy+h-UI_LEFT_BAND;


colors = array(
            COLOR_FOREGROUND(),
            COLOR_BACKGROUND(),
            COLOR_SHADOW()
        );

hoveredColors = array(
            COLOR_BACKGROUND(),
            COLOR_FOREGROUND(),
            COLOR_SHADOW()
        );

disabledColors = array(
            COLOR_BACKGROUND(),
            COLOR_BACKGROUND(),
            COLOR_SHADOW()
        );
        
if (currentPanning &gt; 0){
    currentPanning -= panningSpeed/room_speed;
}
else{
    currentPanning = 0;
    panned = true;
}



if (currentPanning == 0){

    var segments = w/(ds_list_size(availableCavesList)+2);
    for (var i = 0; i &lt; ds_list_size(availableCavesList); i++){
        
        var potentialCave = availableCavesList[|i];
        if (is_undefined(potentialCave[? CAVE_PLANET])){
            potentialCave[? CAVE_PLANET] = currentPlanet;
        }
    
        var lineHeight = string_height("A");
        var block = array(segments*(i*2+1) -buttonWidth/2, nextHeight -buttonHeight/2, segments*(i*2+1) +buttonWidth/2, nextHeight +buttonHeight/2);
        
        if (mouseIn(block)){
            hoveredCave = i;
            var cave = availableCavesList[|hoveredCave];
            var text = translate(CAVE_BONUS, cave[? CAVE_BONUS])+": "+translate("CAVE_TIP", string(CAVE_BONUS)+"."+string(cave[? CAVE_BONUS]))+"#"
                        + translate(CAVE_MALUS, cave[? CAVE_MALUS])+": "+translate("CAVE_TIP", string(CAVE_MALUS)+"."+string(cave[? CAVE_MALUS]));
            drawTip(stripAccents(text));
            
            if (global.i[I_SELECT]){
                playSfx(sound_sfx_select);
                pre = instance_create(0,0,object_ui_window_premission);
                pre.cave = availableCavesList[|i];
            }
        }
        else if (hoveredCave == i){
            hoveredCave = noone;
        }
        
    }
    
    var backWidth = 64;
    var backHeight = 32;

    /// BACK TO MENU button
    var explore = array(left+interiorPadding, top+height-interiorPadding*4-backHeight, left+backWidth*2, top+height-interiorPadding*4);
    
    if (mouseIn(explore)){
        hoveredBack = true;
        if (global.i[I_SELECT]){
            playSfx(sound_sfx_select);
            fadeToRoom(station_main);
        }
    }
    else{
        hoveredBack = false;
    }
    
    // RELOCATE STATION button    
    if (object_game.currentLevel &lt;= 1){
        disabledRelocate = true;
    }
    else{
        disabledRelocate = false;
    }
    var changeButtonWidth = backWidth*2 + interiorPadding;
    var box = array(explore[0]+changeButtonWidth, explore[1], explore[2]+changeButtonWidth, explore[3]);
    if (mouseIn(box) &amp;&amp; !disabledRelocate){
        hoveredRelocate = true;
        drawTip(translate("RELOCATION", "hoverTip" ));
        if (global.i[I_SELECT]){
            pre = instance_create(0,0,object_ui_window_relocation);
        }
    }
    else{
        if (mouseIn(box)){
            drawTip(translate("RELOCATION", "disabledHoverTip" ));
        }
        hoveredRelocate = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF NOT SELECTCAVE ROOM
if (room != station_selectcave){
    if (object_backgroundfader.bgm == sound_bgm_stationwizard_3){
        bgmFade(sound_void);
    }
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>bgmFade(sound_bgm_stationwizard_3);

scrollLevel = scrollUnit*object_game.currentLevel;
/*
room_set_background(room, 0, true, false, background_dirt, 0, scrollLevel%SCREEN_HEIGHT, false, true, 0, 0, 1);
background_blend[0] = COLOR_FOREGROUND();
*/
lastName = generateCaveName(object_game.lastCave)
if (object_game.currentLevel &lt;= 1 &amp;&amp; !panned){
    currentPanning = panningStart;    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF NOT SELECTCAVE ROOM
if (room != station_selectcave){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var w = view_wview;
var h = view_hview;
var vx = view_xview;
var vy = view_yview;
    
var left = vx+UI_LEFT_BAND+interiorPadding;
var right = vx+w-interiorPadding-UI_RIGHT_BAND;
var top = vy+UI_TOP_BAND+interiorPadding;
var height = vy+h-UI_LEFT_BAND;

draw_set_font(font_ui);
draw_set_valign(fa_middle);
draw_set_halign(fa_center);

var skyColor = make_colour_hsv(object_game.lastCave[? CAVE_SEED]%255, 255, 128);
var darkSky = merge_colour(skyColor, c_black, 0.6);

/// Backgrounds
if (object_game.currentLevel &lt;= 1){
    draw_rectangle_colour(0, currentPanning-h, w, currentPanning+previousHeight, 
        darkSky, darkSky,
        skyColor, skyColor,
        false);
        
    draw_sprite(sprite_bg_dirt, 0, 0, currentPanning+previousHeight);
    
    draw_sprite_ext(sprite_station_profile, 1, w/2, currentPanning+previousHeight, 1, 1, 0, COLOR_FOREGROUND(), 1);
    draw_sprite_ext(sprite_station_profile, 0, w/2, currentPanning+previousHeight, 1, 1, 0, COLOR_BACKGROUND(), 1);
    drawShadowedText(w/2, currentPanning+previousHeight-sprite_get_height(sprite_stationwizard)-8, object_station.company[? "name"], colors);
}
else{
    draw_sprite(sprite_bg_dirt, 0, 0, 0+scrollLevel%sprite_get_height(sprite_bg_dirt));
    draw_sprite(sprite_bg_dirt, 0, 0, -sprite_get_height(sprite_bg_dirt)+scrollLevel%sprite_get_height(sprite_bg_dirt));
}

if (currentPanning == 0){
    
    /// Branches
    var thickness = 2;
    if (object_game.currentLevel &lt;= 1){
        drawBlock(array(w/2 - thickness/2, currentPanning+previousHeight, w/2 + thickness/2, currentPanning+branchHeight), colors);
    }
    else{
        drawBlock(array(w/2 - thickness/2, 0, w/2 + thickness/2, branchHeight), colors);
    }
    drawBlock(array(w/4, branchHeight-thickness/2, (w*3)/4, branchHeight+thickness/2), colors);
    drawBlock(array(w/4 - thickness/2, branchHeight, w/4 + thickness/2, nextHeight), colors);
    drawBlock(array((w*3)/4 - thickness/2, branchHeight, (w*3)/4 + thickness/2, nextHeight), colors);
    
    // Station / original cave
    if (object_game.currentLevel &gt; 1){
    
        var cave = object_game.lastCave;
        var text = generateCaveName(cave)+"##"+translate(CAVE_BONUS, cave[? CAVE_BONUS])+"#"+translate(CAVE_MALUS, cave[? CAVE_MALUS]);
        
        var block = array(  w/2-buttonWidth/2, 
                            previousHeight-buttonHeight/2,
                            w/2+buttonWidth/2, 
                            previousHeight+buttonHeight/2
                    );
        drawBlock(block, disabledColors);
        drawShadowedText(floormean(block[0], block[2]), floormean(block[1], block[3]), text, disabledColors);
    }
    
    // Forked caves
    var segments = w/(ds_list_size(availableCavesList)+2);
    for (var i = 0; i &lt; ds_list_size(availableCavesList); i++){
        var cave = availableCavesList[| i];
        var text = generateCaveName(cave);
        var lineHeight = string_height("A");
        
        var block = array(segments*(i*2+1) -buttonWidth/2, nextHeight -buttonHeight/2, segments*(i*2+1) +buttonWidth/2, nextHeight +buttonHeight/2);
           
        var myColors = colors;
        if (hoveredCave == i){
            myColors = hoveredColors;
        }
        drawBlock(block, myColors); 
        drawShadowedText(
                floormean(block[0], block[2]), 
                floormean(block[1]-lineHeight/2, block[3]-lineHeight/2)-lineHeight, 
                text,
                myColors
                        );
                        
        drawShadowedText(
                floormean(block[0], block[2]), 
                floormean(block[1]-lineHeight/2, block[3]-lineHeight/2)+lineHeight, 
                translate(CAVE_BONUS, cave[? CAVE_BONUS]),
                array(c_lime, myColors[1], myColors[2])
                        );
                        
        drawShadowedText(
                floormean(block[0], block[2]), 
                floormean(block[1]-lineHeight/2, block[3]-lineHeight/2)+lineHeight*2, 
                translate(CAVE_MALUS, cave[? CAVE_MALUS]),
                array(c_red, myColors[1], myColors[2])
                        );
    }

    /// Depth indicator
    var start = previousHeight;
    if (!disabledRelocate){
        start = 0;
    }
    
    for (var i = previousHeight-unitScale; i &lt;= nextHeight; i+= unitScale/2){
        
        var posY = i;
        var setBackMul = 1;
        if ((i-previousHeight)/unitScale != floor((i-previousHeight)/unitScale)){
            setBackMul = 0.5
        }
        var block = array(rulerX-setBack*setBackMul, posY-thickness/2, rulerX, posY+thickness/2);
        drawBlock(block, colors);
                
        draw_set_halign(fa_right);
        if ((i-previousHeight)/unitScale == floor((i-previousHeight)/unitScale)){
            var markerDepth = depthUnit* (object_game.currentLevel+ floor(i/unitScale)) - depthUnit;
            
            drawShadowedText(rulerX-setBack-2, posY, string(markerDepth)+"km");
        }
    }
    
    drawBlock(
        array(rulerX-thickness/2, start, rulerX+thickness/2, nextHeight),
        colors
    );
    
        
    /// BACK TO MENU button
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);

    var backWidth = 64;
    var backHeight = 32;
    
    var explore = array(left+interiorPadding, top+height-interiorPadding*4-backHeight, left+backWidth*2, top+height-interiorPadding*4);
    var text = "&lt;&lt; "+translate("STATION_HOME", "back");
    var theseColors = colors;
    if (hoveredBack){
        theseColors = hoveredColors;
    }
    drawBlock(explore, theseColors);
    drawShadowedText(mean(explore[0], explore[2]), mean(explore[1], explore[3]), text, theseColors);
    
    /// PLANET indicator
    draw_set_halign(fa_right);
    draw_set_valign(fa_top);
    
    var position = array(round(right-interiorPadding*2), round(top+interiorPadding*2));
    var txt = translate("CAVE_TIP", "planet");
    var planetName = translate("EMMET_BIRTHPLACE", currentPlanet);
    
    draw_set_font(font_name);
    var heightUnit = string_height("A");
    drawShadowedText(
        position[0],
        position[1], 
        txt, 
        colors
    );
    
    draw_set_font(font_ui_big);
    drawShadowedText(
        position[0],
        position[1] + heightUnit, 
        planetName, 
        colors
    );
    
    // Change planet button
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    var changeButtonWidth = backWidth*2 + interiorPadding;
    var box = array(explore[0]+changeButtonWidth, explore[1], explore[2]+changeButtonWidth, explore[3]);
    var theseColors = colors;
    if (hoveredRelocate){
        theseColors = hoveredColors;
    }
    if (object_game.currentLevel &lt;= 1){
        theseColors = disabledColors;
    }
    draw_set_font(font_ui);
    drawBlock(box, theseColors);
    drawShadowedText(floormean(box[0], box[2]), floormean(box[1], box[3]), translate("CAVE_TIP", "changePlanet"), theseColors);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
