<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite_ui_train_dynamite</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hostWindow = createWindow(translate("EMMETSUNITED", "trainEmmet"), "", 
    array(noone), true);

depth = hostWindow.depth-1;

hostWindow.width = 320;
hostWindow.height = 192;
hostWindow.x = (SCREEN_WIDTH-hostWindow.width)/2;
hostWindow.y = (SCREEN_HEIGHT-hostWindow.height)/2;

x = hostWindow.x+UI_LEFT_BAND;
y = hostWindow.y+UI_TOP_BAND;

interiorPadding = 8;
textInteriorPadding = 5;

xButtonSize = UI_TOP_BAND-2;

hostWindow.controlButtonsSize = xButtonSize+interiorPadding;

width = hostWindow.width - UI_RIGHT_BAND - UI_LEFT_BAND;
height = hostWindow.height - UI_TOP_BAND - UI_LEFT_BAND;

colors = 
        array(COLOR_FOREGROUND(),
                c_black, 
                COLOR_SHADOW());
hoveredColors = 
        array(COLOR_BACKGROUND(),
                COLOR_FOREGROUND(), 
                COLOR_SHADOW());
greyedColors = 
        array(COLOR_SHADOW(),
                c_black, 
                COLOR_SHADOW());
                
hoveredX = false;

buttonMargin = 4;
buttonWSpacing = 12;
buttonWidth = 64;
buttonZoneHeight = 32;
buttonHeight = buttonZoneHeight-buttonMargin;

calculated = false;
totalCost = 0;

hoveredBack = false;
hoveredOK = false;
hoveredRight = false;
hoveredLeft = false;
greyedRight = false;
greyedLeft = false;

currentEmmetIndex = 0;
arrowBlockWidth = 16;
animIndex = 0;
animSpeed = 10;

training = noone;
price = 0;
fakeCrewList = ds_list_create();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// EXIT IF WINDOWS ONTOP
willExit = anotherWindowOnTop();
if (willExit){
    exit;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vx = view_xview;
var vy = view_yview;

var left = vx+x+interiorPadding;
var right = vx+x+width-interiorPadding-UI_RIGHT_BAND;
var top = vy+y+interiorPadding+UI_TOP_BAND;
var bottom = vy+y+height+interiorPadding-UI_LEFT_BAND-UI_TOP_BAND;


/// 0. Close button
var pos = array(vx+x+width-xButtonSize, vy+y-UI_TOP_BAND, vx+x+width+UI_RIGHT_BAND, vy+y-UI_TOP_BAND+xButtonSize);
if (mouseIn(pos)){
    hoveredX = true;
    if (global.i[I_SELECT]){
        playSfx(sound_sfx_select);
        closeWindow(hostWindow);
        instance_destroy();
    }
}
else{
    hoveredX = false;
}

/// FakeCrew
ds_list_destroy(fakeCrewList);
fakeCrewList = ds_list_create();
for (var i = 0; i &lt; ds_list_size(object_station.crew); i++){
    var em = object_station.crew[|i];
    var trainings = em[? "trainings"];
    var has = false;
    for (var j = 0; j &lt; ds_list_size(em[? "trainings"]); j++){
        var thisTraining = trainings[| j];
        if (thisTraining == training){
            has = true;
            break;
        }
    }
    if (!has){
        ds_list_add(fakeCrewList, em);
        // No need to mark as map - we don't want to kill that emmet
    }
}

/// Training zone
draw_set_valign(fa_top);    
draw_set_font(font_ui);
var lh = string_height("A");

var fakeSurf = array(right-left, bottom-top-buttonZoneHeight - 8);

var displayZone = array(left, top, left+fakeSurf[0], top+fakeSurf[1]);

var currentEmmet = fakeCrewList[| currentEmmetIndex];

var charBlock = array(left+width/4, top+lh*3, right-width/4, top+lh*5);
var leftArrow = array(charBlock[0]-arrowBlockWidth, charBlock[1], charBlock[0], charBlock[3]);
var rightArrow = array(charBlock[2], charBlock[1], charBlock[2]+arrowBlockWidth, charBlock[3]);

if (currentEmmetIndex == 0){
    greyedLeft = true;
}
else{
    greyedLeft = false;
}

if (currentEmmetIndex == ds_list_size(fakeCrewList)-1){
    greyedRight = true;
}
else{
    greyedRight = false;
}

if (mouseIn(leftArrow) &amp;&amp; !greyedLeft){
    hoveredLeft = true;
    if (global.i[I_SELECT]){
        playSfx(sound_sfx_select);
        currentEmmetIndex--;
    }
}
else{
    hoveredLeft = false;
}
if (mouseIn(rightArrow) &amp;&amp; !greyedRight){
    hoveredRight = true;
    if (global.i[I_SELECT]){
        playSfx(sound_sfx_select);
        currentEmmetIndex++;
    }
}
else{
    hoveredRight = false;
}


/// Bottom buttons

var confirmBlock = array(right-buttonWidth, bottom-buttonZoneHeight, right, bottom);
if (mouseIn(confirmBlock)){
    hoveredOK = true;
    if (global.i[I_SELECT]){
        var em = fakeCrewList[| currentEmmetIndex];
        ds_list_destroy(fakeCrewList);
        fakeCrewList = noone;
        ds_list_add(em[? "trainings"], training);
        remFunds(price);
        addToStat('emmetsTrained', 1);
        addToStat('moneySpentOnTrainings', price);
        playSfx(sound_sfx_select);
        closeWindow(hostWindow);
        instance_destroy();
    }
}
else{
    hoveredOK = false;
}

var backBlock = array(left, bottom-buttonZoneHeight, left+buttonWidth, bottom);
if (mouseIn(backBlock)){
    hoveredBack = true;
    if (global.i[I_SELECT]){
        ds_list_destroy(fakeCrewList);
        fakeCrewList = noone;
        playSfx(sound_sfx_select);
        closeWindow(hostWindow);
        instance_destroy();
    }
}
else{
    hoveredBack = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var vx = view_xview;
var vy = view_yview;

var left = vx+x+interiorPadding;
var right = vx+x+width-interiorPadding-UI_RIGHT_BAND;
var top = vy+y+interiorPadding+UI_TOP_BAND;
var bottom = vy+y+height+interiorPadding-UI_LEFT_BAND-UI_TOP_BAND;


/// 0. Close button
var pos = array(vx+x+width-xButtonSize, vy+y-UI_TOP_BAND, vx+x+width+UI_RIGHT_BAND, vy+y-UI_TOP_BAND+xButtonSize);
var colorsUsed = hostWindow.colors;
if (hoveredX){
    colorsUsed = hostWindow.hoveredColors;
}

drawBlock(pos, colorsUsed);

draw_set_valign(fa_middle);
draw_set_halign(fa_center);
drawShadowedText(pos[0]+(pos[2]-pos[0])/2, pos[1]+(pos[3]-pos[1])/2, "X", colorsUsed);

/// 1. Draw background
draw_set_color(colors[2]);
draw_rectangle(vx+x, vy+y, vx+x+width-2,  vy+y+height-2, false);

draw_set_color(colors[0]);
draw_rectangle(vx+x, vy+y, vx+x+width+2,  vy+y+height+2, false);

draw_set_color(colors[1]);
draw_rectangle(vx+x, vy+y, vx+x+width, vy+y+height, false);

draw_set_font(font_ui);

/// 2. Interior
var lh = string_height("A");
if (fakeCrewList == noone || ds_list_size(fakeCrewList) &lt;= 0){
    exit;
}
var surf = surface_create(right-left, bottom-top-buttonZoneHeight - 8);

if (surface_exists(surf)){
    surface_set_target(surf);
    draw_clear(colors[1]);
    
    var currentEmmet = fakeCrewList[| currentEmmetIndex];
    var charBlock = array(width/4, lh*3, surface_get_width(surf)-width/4, lh*5);
    var leftArrow = array(charBlock[0]-arrowBlockWidth, charBlock[1], charBlock[0], charBlock[3]);
    var rightArrow = array(charBlock[2], charBlock[1], charBlock[2]+arrowBlockWidth, charBlock[3]);
    
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_color(colors[0]);
    drawShadowedText(floor(surface_get_width(surf)/2), floor(lh/2), translate("EMMETSUNITED", "willBeTrainedTo")+"#"+translate("EMMET_TRAINING", training), colors, surface_get_width(surf)-hostWindow.textInteriorPadding*2);
    drawBlock(charBlock, colors);
    draw_set_valign(fa_middle);
    drawShadowedText(floormean(charBlock[0], charBlock[2]), floormean(charBlock[1], charBlock[3]), currentEmmet[? "name"]);
    
    var usedColors = colors;
    if (greyedLeft){
        usedColors = greyedColors;
    }
    else if (hoveredLeft){
        usedColors = hoveredColors;
    }
    draw_set_color(usedColors[0]);
    drawBlock(leftArrow, usedColors);
    draw_arrow(leftArrow[2]-arrowBlockWidth/4, mean(leftArrow[1], leftArrow[3]), leftArrow[0]+arrowBlockWidth/4, mean (leftArrow[1], leftArrow[3]), arrowBlockWidth/2);
    
    usedColors = colors;
    if (greyedRight){
        usedColors = greyedColors;
    }
    else if (hoveredRight){
        usedColors = hoveredColors;
    }
    draw_set_color(usedColors[0]);
    drawBlock(rightArrow, usedColors);
    draw_arrow(rightArrow[0]+arrowBlockWidth/4, mean(rightArrow[1], rightArrow[3]), rightArrow[2]-arrowBlockWidth/4, mean (rightArrow[1], rightArrow[3]), arrowBlockWidth/2);
    
    draw_sprite_ext(sprite_emmet_walking_side, floor(animIndex), charBlock[0]+8, mean(charBlock[1], charBlock[3])+floor(sprite_get_height(sprite_emmet_walking_side)/2), 1, 1, 0, getEmmetColor(currentEmmet), 1);
    animIndex = (animIndex + animSpeed/room_speed)%sprite_get_number(sprite_emmet_walking_side);
    
    /// To step    
    surface_reset_target();
    drawBorders(array(left, top, left+surface_get_width(surf), top+surface_get_height(surf)), colors);
    draw_surface(surf, left, top);
    surface_free(surf);
    
    var displayZoneHeight = (bottom-top-buttonZoneHeight)-8;
}            
    
    
/// 3. Buttons
draw_set_valign(fa_middle);
draw_set_halign(fa_center);
var myColors = colors;
if (hoveredBack){
    myColors = hoveredColors;
}
var backBlock = array(left, bottom-buttonZoneHeight, left+buttonWidth, bottom);
drawBlock(backBlock, myColors);
drawShadowedText(floormean(backBlock[0], backBlock[2]), floormean(backBlock[1], backBlock[3]), translate("GENERAL_UI", "cancel"));

var myColors = colors;
if (hoveredOK){
    myColors = hoveredColors;
}
var confirmBlock = array(right-buttonWidth, bottom-buttonZoneHeight, right, bottom);
drawBlock(confirmBlock, myColors);
drawShadowedText(floormean(confirmBlock[0], confirmBlock[2]), floormean(confirmBlock[1], confirmBlock[3]), translate("GENERAL_UI", "confirm"));

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
